---
title: "Data exploration and cleaning"
output:
  word_document: default
  html_document:
    df_print: paged
  pdf_document: default
---

This notebook performs a basic overview of the data and analyses the genetic diversity indicators. It uses as input the "clean kobo output" that was first cleaned by `1.2_cleaning`.

## Get data and functions

Load required libraries:

```{r, warning=FALSE, message=FALSE}
library(tidyr)
library(dplyr)
library(utile.tools)
library(stringr)
library(ggplot2)
library(ggsankey)
library(alluvial)
library(viridis)
```

Load required functions. These custom fuctions are available at: https://github.com/AliciaMstt/GeneticIndicators

```{r}
source("get_indicator1_data.R")
source("get_indicator2_data.R")
source("get_indicator3_data.R")
source("get_metadata.R")
```

Other custom functions:
```{r}
# to imitate ggplot colors, thanks to https://stackoverflow.com/questions/8197559/emulate-ggplot2-default-color-palette
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}
```


Get indicator 1 and indicator 2 data from clean kobo output
```{r}
# Get data:
kobo_clean<-read.csv(file="kobo_output_clean.csv", header=TRUE)

# Extract indicator 1 data from kobo output, show most relevant columns
ind1_data<-get_indicator1_data(kobo_output=kobo_clean)
head(ind1_data[,c(1:3, 12:14)])

# Extract indicator 2 data from kobo output, show most relevant columns
ind2_data<-get_indicator2_data(kobo_output=kobo_clean)
head(ind2_data[,c(1:3, 9:10,13)])

# Extract indicator 3 data from kobo output, show most relevant columns
ind3_data<-get_indicator3_data(kobo_output=kobo_clean)
head(ind3_data[,c(1:3, 9:11)])

# extract metadata, show most relevant columns
metadata<-get_metadata(kobo_output=kobo_clean)
head(metadata[,c(1:3, 12, 25,26)])

```


## General description of the dataset

### Total number of taxa and taxa assessed more than once.

Records by country, including taxa assessed more than once (see below for details on this)

```{r}
ggplot(metadata, aes(x=country_assessment)) + 
  geom_bar(stat = "count") +
  ggtitle("Number of taxa assessedd by country, including duplicated taxa")

```

Records by taxonomic groups

```{r}
ggplot(metadata, aes(x=taxonomic_group)) + 
  geom_bar(stat = "count") +
  theme(axis.text.x = element_text(angle = 45)) +
  ggtitle("Number of taxa assessedd by taxonomic group, including duplicated taxa")

```

Some taxa were assessed twice, for example to account for uncertainty on how to divide populations.

Check how many taxa were analysed twice:

```{r}
# object with duplicated taxa
metadata_duplicates<-metadata[duplicated(metadata$taxon), ]

# how many?
nrow(metadata_duplicates)
```

How many unique?

```{r}
# object with unique taxa
metadata_unique<-metadata[!duplicated(metadata$taxon), ]

# how many?
nrow(metadata_unique)
```


Of which countries and taxonomic groups are the taxa that were assessed more than once?
```{r}
ggplot(metadata_duplicates, aes(x=country_assessment)) + 
  geom_bar(stat = "count") +
  ggtitle("Number of taxa assessed more than once, by country")

```

```{r}
ggplot(metadata_duplicates, aes(x=taxonomic_group, fill=country_assessment)) + 
  geom_bar(stat = "count") +
  theme(axis.text.x = element_text(angle = 45)) +
  ggtitle("Number of taxa assessed more than once")

```

**Now check taxa assessed excluding duplicates, i.e. the real number of taxa assessed. This will be used in downstream analyses**

```{r}
ggplot(metadata_unique, aes(x=country_assessment)) + 
  geom_bar(stat = "count") +
  ggtitle("Number of taxa assessed by country")

```

```{r}
ggplot(metadata_unique, aes(x=taxonomic_group)) + 
  geom_bar(stat = "count") +
  theme(axis.text.x = element_text(angle = 45)) +
  ggtitle("Number of taxa assessed by taxonomic group")

```


### Sankey and alluvial fun

Note: The following plots keep only one record of the taxa that were assessed more than once.

#### Which taxonomic groups are countries assessing?

Note on alluvial vs Sankey, taken from ggalluvial: An important feature of alluvial plots is the meaningfulness of the vertical axis: No gaps are inserted between the strata, so the total height of the plot reflects the cumulative quantity of the observations. The plots produced by {ggalluvial} conform to the “grammar of graphics” principles of {ggplot2}, and this prevents users from producing “free-floating” visualizations like the Sankey diagrams

Using alluvial:
```{r}
library(alluvial)
# estimate frequencies for alluvial plot
foralluvial_1<-metadata_unique %>% group_by(country_assessment, taxonomic_group) %>%
             summarise(n=n())
head(foralluvial_1)

## plot
# define colors
my_cols<- gg_color_hue(length(unique(foralluvial_1$country_assessment)))

# we need a vector of colors by country for each row of the dataset, so:
countries<-as.factor(foralluvial_1$country_assessment)
levels(countries)<-my_cols
countries<-as.vector(countries)
head(countries)

# plot
alluvial(foralluvial_1[,1:2], freq = foralluvial_1$n,
         col=countries, 
         blocks=FALSE,
         gap.width = 0.3,
         cex=.8, 
         xw = 0.2,
         cw = 0.1,
         border = NA)

```

Using ggsankey
```{r}
library(ggsankey)

# transform data to how ggsankey wants it
df <- metadata_unique %>%
  make_long(country_assessment, taxonomic_group)
df


# Sankey plot
ggplot(df, aes(x = x,
               next_x = next_x,
               node = node,
               next_node = next_node,
               fill = factor(node),
               label = node)) +
  geom_sankey(flow.alpha = 0.6, 
              node.color = NA,
              show.legend = FALSE) +
  geom_sankey_label(size = 2, color = 1, fill = "white") +
  # colour by country
  scale_fill_manual(values=c(scales::hue_pal()(length(unique(metadata$country_assessment))),  # a nice  color for each of the n countries
                             rep("darkgrey", length(unique(metadata$taxonomic_group)))), # grey for the n taxonomic groups
                    breaks=c(unique(metadata$country_assessment), 
                             unique(metadata$taxonomic_group))) +
  theme_sankey(base_size = 10) +
  xlab("")
  

```


How is the distribution of Ne / Nc data across countries and taxa?

Using alluvial:
```{r}
library(alluvial)
# estimate frequencies for alluvial plot
foralluvial_1<-metadata_unique %>% group_by(country_assessment, taxonomic_group, popsize_data) %>%
             summarise(n=n())
head(foralluvial_1)

## plot
# define colors
my_cols<- gg_color_hue(length(unique(foralluvial_1$country_assessment)))

# we need a vector of colors by country for each row of the dataset, so:
countries<-as.factor(foralluvial_1$country_assessment)
levels(countries)<-my_cols
countries<-as.vector(countries)
head(countries)

# plot
alluvial(foralluvial_1[,1:3], freq = foralluvial_1$n,
         col=countries, 
         blocks=FALSE,
         gap.width = 0.5,
         cex=.8, 
         xw = 0.1,
         cw = 0.2,
         border = NA)

```

Using ggsankey option 1
```{r}
# transform data to how ggsankey wants it
df <- metadata_unique %>%
  make_long(country_assessment, taxonomic_group, popsize_data)
df

# Sankey
ggplot(df, aes(x = x,
               next_x = next_x,
               node = node,
               next_node = next_node,
               fill = factor(node),
               label = node)) +
  geom_sankey(flow.alpha = 0.6, 
              show.legend = FALSE) +
  # manually set flow fill according to countries and popsize 
                      # a nice  color for each of the n countries for the first (left) part
  scale_fill_manual(values=c(scales::hue_pal()(length(unique(metadata_unique$country_assessment))),  
                             # grey for the taxonomic groups
                              rep("darkgrey", length(unique(metadata_unique$taxonomic_group))),
                             # three colors for popsize_data
                             c("darkolivegreen", "darkgoldenrod1", "brown3")), 
                    breaks=c(unique(metadata_unique$country_assessment), 
                             unique(metadata_unique$taxonomic_group),
                             unique(metadata_unique$popsize_data))) +

  geom_sankey_label(size = 2, color = 1, fill = "white") +
  theme_sankey(base_size = 10) +
  xlab("")

```

Using ggsankey option 2
```{r}
# transform data to how ggsankey wants it
df <- metadata_unique %>%
  make_long(country_assessment, taxonomic_group, popsize_data)
df

# Sankey
ggplot(df, aes(x = x,
               next_x = next_x,
               node = node,
               next_node = next_node,
               fill = factor(node),
               label = node)) +
  geom_sankey(flow.alpha = 0.6, 
              show.legend = FALSE) +
  # manually set flow fill according to countries and popsize 
                      # a nice  color for each of the n countries for the first (left) part
  scale_fill_manual(values=c(scales::hue_pal()(length(unique(metadata_unique$country_assessment))),  
                             # gradient of soft colors for taxonomic groups
                              cividis(length(unique(metadata_unique$taxonomic_group))),
                             # traffic light for pop data
                             c("darkolivegreen", "darkgoldenrod1", "brown3")), 
                    breaks=c(unique(metadata_unique$country_assessment), 
                             levels(as.factor(metadata_unique$taxonomic_group)),
                             unique(metadata_unique$popsize_data))) +

  geom_sankey_label(size = 2.5, color = "black", fill = "white") +
  theme_sankey(base_size = 10) +
  xlab("")

```



Taxonomic groups and IUCN status

Using alluvial:
```{r}
library(alluvial)
# estimate frequencies for alluvial plot
foralluvial_1<-metadata_unique %>% group_by(taxonomic_group, global_IUCN, popsize_data) %>%
             summarise(n=n())
head(foralluvial_1)

## plot
# define colors according to IUCN categories
# check order of categories:
levels(as.factor(metadata_unique$global_IUCN))

# create vector of colors accordingly:
my_cols<-c("brown2", "darkgrey", "darkorange", "darkgreen", "azure2", "green", "bisque1", "yellow")


# we need a vector of colors by iucn for each row of the dataset, so:
gIUCN<-as.factor(foralluvial_1$global_IUCN)
levels(gIUCN)<-my_cols
gIUCN<-as.vector(gIUCN)
head(gIUCN)

# plot
alluvial(foralluvial_1[,1:3], freq = foralluvial_1$n,
         col=gIUCN, 
         blocks="bookends",
         alpha = 0.6,
         gap.width = 0.4,
         cex=.75, 
         xw = 0.15,
         cw = 0.2,
         border = NA)

```

Using ggsankey

```{r}
# transform data to how ggsankey wants it
df <- metadata %>%
  make_long(taxonomic_group, global_IUCN, popsize_data)
df

# Sankey
ggplot(df, aes(x = x,
               next_x = next_x,
               node = node,
               next_node = next_node,
               fill = factor(node),
               label = node)) +
  geom_sankey(flow.alpha = 0.6, 
              node.color = NA,
              show.legend = FALSE) +
  
    # manually set flow fill 
                       # gradient of soft colors for taxonomic groups
  scale_fill_manual(values= c(cividis(length(unique(metadata_unique$taxonomic_group))),
                       # iucn color codes
                           c("brown2", "darkgrey", "darkorange", "darkgreen", "azure2", "green", "bisque1", "yellow"),
                     # traffic light for pop data
                           c("darkolivegreen", "darkgoldenrod1", "brown3")), 
                    breaks=c(levels(as.factor(metadata_unique$taxonomic_group)), 
                             levels(as.factor(metadata_unique$global_IUCN)),
                             unique(metadata_unique$popsize_data))) +

  geom_sankey_label(size = 2, color = 1, fill = "white") +
  theme_sankey(base_size = 10) +
  xlab("")
```


## Estimate indicator 1

## Estimate indicator 2 (proportion of populations within species which are maintained)

Indicator 2 is the he proportion of populations within species which are maintained. This can be estimated based on the `n_extant_populations` and `n_extint_populations`, as follows:

```{r}
ind2_data$indicator2<- ind2_data$n_extant_populations / (ind2_data$n_extant_populations + ind2_data$n_extint_populations)
head(ind2_data$indicator2)
```


### Distribution of NA in indicator 2

We have NA because in some cases the number of extinct populations is unknown, therefore the above operation cannot be computed. 

Total taxa with NA in extant populations:
```{r}
sum(is.na(ind2_data$n_extant_populations))
```

Which are?
```{r}
ind2_data[is.na(ind2_data$n_extant_populations), 1:3]
```

Total taxa with NA in **extinct** populations:
```{r}
sum(is.na(ind2_data$n_extint_populations))
```

Do taxa with NA for extant also have NA for extinct?

```{r}
ind2_data$taxon[is.na(ind2_data$n_extant_populations)] %in% ind2_data$taxon[is.na(ind2_data$n_extint_populations)]
```

So out of the `r nrow(ind2_data)`, we have `r sum(is.na(ind2_data$indicator2))` where there are NA in either n_extant or n_extinct (`r round(sum(is.na(ind2_data$indicator2))/nrow(ind2_data)*100, 2)`%.). Therefore when estimating indicator 2... **QUESTION: What should we do: A) we can’t estimate indicator 2 in those species, or B) we assume n_extinct = NA = 0, and therefore indicator 2 = 1.**

##### Plots!

By country
```{r}
ind2_data %>%
  ggplot(aes(x=country_assessment, fill=is.na(indicator2)))+
  geom_bar(position = "dodge") +
  coord_flip()
```

By taxonomic group
```{r}
ind2_data %>%
  ggplot(aes(x=taxonomic_group, fill=is.na(indicator2)))+
  geom_bar(position = "dodge") +
  coord_flip()
```

**QUESTION: should we manually check that NA are correct in both extinct or extant pops?**


### Plots for indicator 2 values distribution

For the taxa that do have data, this is how the values of indicator2 are distributed: 

```{r}
hist(ind2_data$indicator2)
```

Visualizing by country

```{r}
# get sample size by desired category

sample_size <- ind2_data %>%
                    filter(!is.na(indicator2)) %>% 
                    group_by(country_assessment) %>% summarize(num=n())

# plot
ind2_data %>% 
  # add sampling size 
  left_join(sample_size) %>%
  mutate(myaxis = paste0(country_assessment, " (n= ", num, ")")) %>%

  # plot
  ggplot(aes(x=myaxis, y=indicator2, fill=country_assessment)) +
  geom_violin(width= 1, linewidth = 0)  +
  geom_jitter(size=.5, width = 0.1) +
  xlab("") +
  coord_flip() +
  theme_bw() +
  theme(panel.border = element_blank(), legend.position="none")

```

Visualizing by taxonomic group:

```{r}
# get sample size by desired category

sample_size <- ind2_data %>%
                    filter(!is.na(indicator2)) %>% 
                    group_by(taxonomic_group) %>% summarize(num=n())

# plot
ind2_data %>% 
  # add sampling size 
  left_join(sample_size) %>%
  mutate(myaxis = paste0(taxonomic_group, " (n= ", num, ")")) %>%
  
  #plot
ggplot(aes(x=myaxis, y=indicator2, fill=taxonomic_group), color=NA) +
      geom_violin(width=2, linewidth = 0)  +
      geom_jitter(size=.5, width = 0.1) +
      xlab("") +
      coord_flip() +
      scale_fill_manual(values= c(cividis(length(unique(ind2_data$taxonomic_group)))),
                    breaks=c(levels(as.factor(ind2_data$taxonomic_group)))) +
      theme_bw() +
      theme(panel.border = element_blank(), legend.position="none")
      
```

Visualizing by IUCN:

```{r}

# add IUCN data form metadata to ind2
ind2_data$global_IUCN <- metadata$global_IUCN

# get sample size by desired category
sample_size <- ind2_data %>%
                    filter(!is.na(indicator2)) %>% 
                    group_by(global_IUCN) %>% summarize(num=n())

# plot
ind2_data %>% 
  # add sampling size 
  left_join(sample_size) %>%
  mutate(myaxis = paste0(global_IUCN, " (n= ", num, ")")) %>%

  # plot
  ggplot(aes(x=myaxis, y=indicator2, fill=global_IUCN)) +
      geom_violin(width=1, linewidth = 0)  +
      geom_jitter(size=.5, width = 0.1) +
      xlab("") +
      coord_flip() +
      scale_fill_manual(values= c("brown2", "darkgrey", "darkorange", "darkgreen", "azure2", "green", "bisque1", "yellow"), # iucn color codes
                    breaks=c(levels(as.factor(ind2_data$global_IUCN)))) +
      theme_bw() +
      theme(panel.border = element_blank(), legend.position="none")
      
```

## Estimate indicator 3


## Session Info for reproducibility purposes:

```{r}
sessionInfo()
```


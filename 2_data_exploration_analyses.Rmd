---
title: "Data exploration and cleaning"
output:
  html_document:
    df_print: paged
  word_document: default
  pdf_document: default
---

This notebook performs a basic overview of the data and analyses the genetic diversity indicators. It uses as input the "clean kobo output" that was first cleaned by `1.2_cleaning`.

## Get data and functions

Load required libraries:

```{r, warning=FALSE, message=FALSE}
library(tidyr)
library(dplyr)
library(utile.tools)
library(stringr)
library(ggplot2)
library(ggsankey)
library(alluvial)
library(viridis)
```

Load required functions. These custom fuctions are available at: https://github.com/AliciaMstt/GeneticIndicators

```{r}
source("get_indicator1_data.R")
source("get_indicator2_data.R")
source("get_indicator3_data.R")
source("get_metadata.R")
```

Other custom functions:
```{r}
# to imitate ggplot colors, thanks to https://stackoverflow.com/questions/8197559/emulate-ggplot2-default-color-palette
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}
```


Get indicator 1 and indicator 2 data from clean kobo output
```{r}
# Get data:
kobo_clean<-read.csv(file="kobo_output_clean.csv", header=TRUE)

# Extract indicator 1 data from kobo output, show most relevant columns
ind1_data<-get_indicator1_data(kobo_output=kobo_clean)
head(ind1_data[,c(1:3, 12:14)])

# Extract indicator 2 data from kobo output, show most relevant columns
ind2_data<-get_indicator2_data(kobo_output=kobo_clean)
head(ind2_data[,c(1:3, 9:10,13)])

# Extract indicator 3 data from kobo output, show most relevant columns
ind3_data<-get_indicator3_data(kobo_output=kobo_clean)
head(ind3_data[,c(1:3, 9:11)])

# extract metadata, show most relevant columns
metadata<-get_metadata(kobo_output=kobo_clean)
head(metadata[,c(1:3, 12, 25,26)])

```


## General description of the dataset

### Total number of taxa and taxa assessed more than once.

Records by country, including taxa assessed more than once (see below for details on this)

```{r}
ggplot(metadata, aes(x=country_assessment)) + 
  geom_bar(stat = "count") +
  ggtitle("Number of taxa assessedd by country, including duplicated taxa")

```

Records by taxonomic groups

```{r}
ggplot(metadata, aes(x=taxonomic_group)) + 
  geom_bar(stat = "count") +
  theme(axis.text.x = element_text(angle = 45)) +
  ggtitle("Number of taxa assessedd by taxonomic group, including duplicated taxa")

```

Some taxa were assessed twice, for example to account for uncertainty on how to divide populations.

Check how many taxa were analysed twice:

```{r}
# object with duplicated taxa
metadata_duplicates<-metadata[duplicated(metadata$taxon), ]

# how many?
nrow(metadata_duplicates)
```

How many unique?

```{r}
# object with unique taxa
metadata_unique<-metadata[!duplicated(metadata$taxon), ]

# how many?
nrow(metadata_unique)
```


Of which countries and taxonomic groups are the taxa that were assessed more than once?
```{r}
ggplot(metadata_duplicates, aes(x=country_assessment)) + 
  geom_bar(stat = "count") +
  ggtitle("Number of taxa assessed more than once, by country")

```

```{r}
ggplot(metadata_duplicates, aes(x=taxonomic_group, fill=country_assessment)) + 
  geom_bar(stat = "count") +
  theme(axis.text.x = element_text(angle = 45)) +
  ggtitle("Number of taxa assessed more than once")

```

**Now check taxa assessed excluding duplicates, i.e. the real number of taxa assessed. This will be used in downstream analyses**

```{r}
ggplot(metadata_unique, aes(x=country_assessment)) + 
  geom_bar(stat = "count") +
  ggtitle("Number of taxa assessed by country")

```

```{r}
ggplot(metadata_unique, aes(x=taxonomic_group)) + 
  geom_bar(stat = "count") +
  theme(axis.text.x = element_text(angle = 45)) +
  ggtitle("Number of taxa assessed by taxonomic group")

```


### Sankey and alluvial fun

Note: The following plots keep only one record of the taxa that were assessed more than once.

#### Which taxonomic groups are countries assessing?

Note on alluvial vs Sankey, taken from ggalluvial: An important feature of alluvial plots is the meaningfulness of the vertical axis: No gaps are inserted between the strata, so the total height of the plot reflects the cumulative quantity of the observations. The plots produced by {ggalluvial} conform to the “grammar of graphics” principles of {ggplot2}, and this prevents users from producing “free-floating” visualizations like the Sankey diagrams

Using alluvial:
```{r}
library(alluvial)
# estimate frequencies for alluvial plot
foralluvial_1<-metadata_unique %>% group_by(country_assessment, taxonomic_group) %>%
             summarise(n=n())
head(foralluvial_1)

## plot
# define colors
my_cols<- gg_color_hue(length(unique(foralluvial_1$country_assessment)))

# we need a vector of colors by country for each row of the dataset, so:
countries<-as.factor(foralluvial_1$country_assessment)
levels(countries)<-my_cols
countries<-as.vector(countries)
head(countries)

# plot
alluvial(foralluvial_1[,1:2], freq = foralluvial_1$n,
         col=countries, 
         blocks=FALSE,
         gap.width = 0.3,
         cex=.8, 
         xw = 0.2,
         cw = 0.1,
         border = NA)

```

Using ggsankey
```{r}
library(ggsankey)

# transform data to how ggsankey wants it
df <- metadata_unique %>%
  make_long(country_assessment, taxonomic_group)
df


# Sankey plot
ggplot(df, aes(x = x,
               next_x = next_x,
               node = node,
               next_node = next_node,
               fill = factor(node),
               label = node)) +
  geom_sankey(flow.alpha = 0.6, 
              node.color = NA,
              show.legend = FALSE) +
  geom_sankey_label(size = 2, color = 1, fill = "white") +
  # colour by country
  scale_fill_manual(values=c(scales::hue_pal()(length(unique(metadata$country_assessment))),  # a nice  color for each of the n countries
                             rep("darkgrey", length(unique(metadata$taxonomic_group)))), # grey for the n taxonomic groups
                    breaks=c(unique(metadata$country_assessment), 
                             unique(metadata$taxonomic_group))) +
  theme_sankey(base_size = 10) +
  xlab("")
  

```


How is the distribution of Ne / Nc data across countries and taxa?

Using alluvial:
```{r}
library(alluvial)
# estimate frequencies for alluvial plot
foralluvial_1<-metadata_unique %>% group_by(country_assessment, taxonomic_group, popsize_data) %>%
             summarise(n=n())
head(foralluvial_1)

## plot
# define colors
my_cols<- gg_color_hue(length(unique(foralluvial_1$country_assessment)))

# we need a vector of colors by country for each row of the dataset, so:
countries<-as.factor(foralluvial_1$country_assessment)
levels(countries)<-my_cols
countries<-as.vector(countries)
head(countries)

# plot
alluvial(foralluvial_1[,1:3], freq = foralluvial_1$n,
         col=countries, 
         blocks=FALSE,
         gap.width = 0.5,
         cex=.8, 
         xw = 0.1,
         cw = 0.2,
         border = NA)

```

Using ggsankey option 1
```{r}
# transform data to how ggsankey wants it
df <- metadata_unique %>%
  make_long(country_assessment, taxonomic_group, popsize_data)
df

# Sankey
ggplot(df, aes(x = x,
               next_x = next_x,
               node = node,
               next_node = next_node,
               fill = factor(node),
               label = node)) +
  geom_sankey(flow.alpha = 0.6, 
              show.legend = FALSE) +
  # manually set flow fill according to countries and popsize 
                      # a nice  color for each of the n countries for the first (left) part
  scale_fill_manual(values=c(scales::hue_pal()(length(unique(metadata_unique$country_assessment))),  
                             # grey for the taxonomic groups
                              rep("darkgrey", length(unique(metadata_unique$taxonomic_group))),
                             # three colors for popsize_data
                             c("darkolivegreen", "darkgoldenrod1", "brown3")), 
                    breaks=c(unique(metadata_unique$country_assessment), 
                             unique(metadata_unique$taxonomic_group),
                             unique(metadata_unique$popsize_data))) +

  geom_sankey_label(size = 2, color = 1, fill = "white") +
  theme_sankey(base_size = 10) +
  xlab("")

```

Using ggsankey option 2
```{r}
# transform data to how ggsankey wants it
df <- metadata_unique %>%
  make_long(country_assessment, taxonomic_group, popsize_data)
df

# Sankey
ggplot(df, aes(x = x,
               next_x = next_x,
               node = node,
               next_node = next_node,
               fill = factor(node),
               label = node)) +
  geom_sankey(flow.alpha = 0.6, 
              show.legend = FALSE) +
  # manually set flow fill according to countries and popsize 
                      # a nice  color for each of the n countries for the first (left) part
  scale_fill_manual(values=c(scales::hue_pal()(length(unique(metadata_unique$country_assessment))),  
                             # gradient of soft colors for taxonomic groups
                              cividis(length(unique(metadata_unique$taxonomic_group))),
                             # traffic light for pop data
                             c("darkolivegreen", "darkgoldenrod1", "brown3")), 
                    breaks=c(unique(metadata_unique$country_assessment), 
                             unique(metadata_unique$taxonomic_group),
                             unique(metadata_unique$popsize_data))) +

  geom_sankey_label(size = 2.5, color = "black", fill = "white") +
  theme_sankey(base_size = 10) +
  xlab("")

```



Taxonomic groups and IUCN status

Using alluvial:
```{r}
library(alluvial)
# estimate frequencies for alluvial plot
foralluvial_1<-metadata_unique %>% group_by(taxonomic_group, global_IUCN, popsize_data) %>%
             summarise(n=n())
head(foralluvial_1)

## plot
# define colors according to IUCN categories
# check order of categories:
levels(as.factor(metadata_unique$global_IUCN))

# create vector of colors accordingly:
my_cols<-c("brown2", "darkgrey", "darkorange", "darkgreen", "azure2", "green", "bisque1", "yellow")


# we need a vector of colors by iucn for each row of the dataset, so:
gIUCN<-as.factor(foralluvial_1$global_IUCN)
levels(gIUCN)<-my_cols
gIUCN<-as.vector(gIUCN)
head(gIUCN)

# plot
alluvial(foralluvial_1[,1:3], freq = foralluvial_1$n,
         col=gIUCN, 
         blocks="bookends",
         alpha = 0.6,
         gap.width = 0.4,
         cex=.75, 
         xw = 0.15,
         cw = 0.2,
         border = NA)

```

Using ggsankey

```{r}
# transform data to how ggsankey wants it
df <- metadata %>%
  make_long(taxonomic_group, global_IUCN, popsize_data)
df

# Sankey
ggplot(df, aes(x = x,
               next_x = next_x,
               node = node,
               next_node = next_node,
               fill = factor(node),
               label = node)) +
  geom_sankey(flow.alpha = 0.6, 
              node.color = NA,
              show.legend = FALSE) +
  
    # manually set flow fill 
                       # gradient of soft colors for taxonomic groups
  scale_fill_manual(values= c(cividis(length(unique(metadata_unique$taxonomic_group))),
                       # iucn color codes
                           c("brown2", "darkgrey", "darkorange", "darkgreen", "azure2", "green", "bisque1", "yellow"),
                     # traffic light for pop data
                           c("darkolivegreen", "darkgoldenrod1", "brown3")), 
                    breaks=c(unique(metadata_unique$taxonomic_group), 
                             levels(as.factor(metadata_unique$global_IUCN)),
                             unique(metadata_unique$popsize_data))) +

  geom_sankey_label(size = 2, color = 1, fill = "white") +
  theme_sankey(base_size = 10) +
  xlab("")
```


## Estimate indicator 1

## Estimate indicator 2

## Estimate indicator 3


## Session Info for reproducibility purposes:

```{r}
sessionInfo()
```


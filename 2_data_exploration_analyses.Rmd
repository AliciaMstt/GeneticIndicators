---
title: "Data exploration and analyses"
output:
  html_document:
    df_print: paged
  word_document: default
  pdf_document: default
---

```{r global-options, include=FALSE}
# options when we want to knit only showing text, results and plots: ie no code, warnings etc.
# knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE) 
```


This notebook performs a basic overview of the data and analyses the genetic diversity indicators. It uses as input the "clean kobo output" that was first cleaned by `1.2_cleaning`.

## Get data and functions

Load required libraries:

```{r, warning=FALSE, message=FALSE}
library(tidyr)
library(dplyr)
library(utile.tools)
library(stringr)
library(ggplot2)
library(ggsankey)
library(alluvial)
library(viridis)
```

Load required functions. These custom fuctions are available at: https://github.com/AliciaMstt/GeneticIndicators

```{r}
source("get_indicator1_data.R")
source("get_indicator2_data.R")
source("get_indicator3_data.R")
source("get_metadata.R")
```

Other custom functions:
```{r}
# to imitate ggplot colors, thanks to https://stackoverflow.com/questions/8197559/emulate-ggplot2-default-color-palette
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}
```


Get indicators data from clean kobo output
```{r, echo=TRUE}
# Get data:
kobo_clean<-read.csv(file="kobo_output_clean.csv", header=TRUE)

# Extract indicator 1 data from kobo output, show most relevant columns
ind1_data<-get_indicator1_data(kobo_output=kobo_clean)
head(ind1_data[,c(1:3, 12:14)])

# Extract indicator 2 data from kobo output, show most relevant columns
ind2_data<-get_indicator2_data(kobo_output=kobo_clean)
head(ind2_data[,c(1:3, 9:10,13)])

# Extract indicator 3 data from kobo output, show most relevant columns
ind3_data<-get_indicator3_data(kobo_output=kobo_clean)
head(ind3_data[,c(1:3, 9:11)])

# extract metadata, show most relevant columns
metadata<-get_metadata(kobo_output=kobo_clean)
head(metadata[,c(1:3, 12, 25,26, 64)])

```


## General description of the dataset

### Total number of taxa and taxa assessed more than once.

Records by country, including taxa assessed more than once (see below for details on this)

```{r, out.width="700px", out.height="400px"}
ggplot(metadata, aes(x=country_assessment)) + 
  geom_bar(stat = "count") +
  ggtitle("Number of taxa assessedd by country, \nincluding duplicated taxa")

```

Did countries used kobo or tabular?

```{r, out.width="700px", out.height="400px" }
ggplot(metadata, aes(x=country_assessment, fill=kobo_tabular)) + 
  geom_bar(stat = "count") +
  ggtitle("Number of taxa assessedd by country, \nincluding duplicated taxa")

```

Records by taxonomic groups

```{r, out.width="700px", out.height="400px"}
ggplot(metadata, aes(x=taxonomic_group)) + 
  geom_bar(stat = "count") +
  theme(axis.text.x = element_text(angle = 45)) +
  ggtitle("Number of taxa assessedd by taxonomic group, \nincluding duplicated taxa")

```

Some taxa were assessed twice, for example to account for uncertainty on how to divide populations. This information is stored in variable `multiassessment` of the metadata (created by `get_metadata()`). An example of taxa with multiple assessments:

```{r}
metadata %>%
filter(multiassessment=="multiassessment")  %>%
  select(taxonomic_group, taxon, country_assessment, multiassessment) %>%
  arrange(taxon, country_assessment) %>%
  head()
  
```
In total these are the number or records (assessment) done for both categories:

```{r}
table(metadata$multiassessment)
``` 

The above numbers refer to the number or records, if what we want is to know how many **taxa** were analysed for each category, then:

Number of taxa with multiple submissions:
```{r}
multi_taxa<- metadata %>%
                filter(multiassessment=="multiassessment") %>%
                select(taxon, country_assessment, taxonomic_group) %>%
                unique()
# how many?
nrow(multi_taxa)
```

Number of taxa with single submissions:

```{r}
single_taxa<- metadata %>%
                filter(multiassessment=="single_assessment") %>%
                select(taxon, country_assessment, taxonomic_group) %>%
                unique()
# how many?
nrow(single_taxa)
```

To explore what kind of taxa countries assessed regardless of if they assessed them once or more, lets create a dataset keeping all single assessed taxa, plus only the first assessment for taxa assessed multiple times. 

```{r}
# object with single assessed taxa, plus only the first assessment for taxa assessed multiple times
metadata_firstmulti<-metadata[!duplicated(cbind(metadata$taxon, metadata$country_assessment)), ]

```

How many records?
```{r}
# how many?
nrow(metadata_firstmulti)
```

Of which countries and taxonomic groups are the taxa that were assessed more than once?
```{r}
metadata_firstmulti %>% # we use the _firstmulti dataset so that multiassesed records are counted only once
        filter(multiassessment=="multiassessment") %>%
      ggplot(aes(x=country_assessment)) + 
        geom_bar(stat = "count") +
        ggtitle("Number of taxa assessed more than once, by country")

```

```{r}
metadata_firstmulti %>% # we use the _unique dataset so that multiassesed records are counted only once
        filter(multiassessment=="multiassessment") %>%

ggplot(aes(x=taxonomic_group, fill=country_assessment)) + 
  geom_bar(stat = "count") +
  theme(axis.text.x = element_text(angle = 45)) +
  ggtitle("Number of taxa assessed more than once")

```

**Now check taxa assessed excluding duplicates, i.e. the real number of taxa assessed. This will be used in downstream analyses**

```{r, out.width="700px", out.height="400px"}
ggplot(metadata_firstmulti, aes(x=country_assessment)) + 
  geom_bar(stat = "count") +
  ggtitle("Number of taxa assessed by country")

```

```{r}
ggplot(metadata_firstmulti, aes(x=taxonomic_group)) + 
  geom_bar(stat = "count") +
  theme(axis.text.x = element_text(angle = 45)) +
  ggtitle("Number of taxa assessed by taxonomic group")

```


### Sankey and alluvial fun

Note: The following plots in this section consider only one record of the taxa that were assessed more than once. That is a total of `r nrow(metadata_firstmulti)` taxa.

#### Which taxonomic groups are countries assessing?

Note on alluvial vs Sankey, taken from ggalluvial: An important feature of alluvial plots is the meaningfulness of the vertical axis: No gaps are inserted between the strata, so the total height of the plot reflects the cumulative quantity of the observations. The plots produced by {ggalluvial} conform to the “grammar of graphics” principles of {ggplot2}, and this prevents users from producing “free-floating” visualizations like the Sankey diagrams

Using alluvial:
```{r, out.width="700px", out.height="500px"}
library(alluvial)
# estimate frequencies for alluvial plot
foralluvial_1<-metadata_firstmulti %>% group_by(country_assessment, taxonomic_group) %>%
             summarise(n=n())
head(foralluvial_1)

## plot
# define colors
my_cols<- gg_color_hue(length(unique(foralluvial_1$country_assessment)))

# we need a vector of colors by country for each row of the dataset, so:
countries<-as.factor(foralluvial_1$country_assessment)
levels(countries)<-my_cols
countries<-as.vector(countries)
head(countries)

# plot
alluvial(foralluvial_1[,1:2], freq = foralluvial_1$n,
         col=countries, 
         blocks=FALSE,
         gap.width = 0.3,
         cex=.8, 
         xw = 0.2,
         cw = 0.1,
         border = NA)

```

Using ggsankey
```{r, out.width="600px", out.height="580px"}
library(ggsankey)

# transform data to how ggsankey wants it
df <- metadata_firstmulti %>%
  make_long(country_assessment, taxonomic_group)

# Sankey plot
ggplot(df, aes(x = x,
               next_x = next_x,
               node = node,
               next_node = next_node,
               fill = factor(node),
               label = node)) +
  geom_sankey(flow.alpha = 0.6, 
              node.color = NA,
              show.legend = FALSE) +
  geom_sankey_label(size = 2, color = 1, fill = "white") +
  # colour by country
  scale_fill_manual(values=c(scales::hue_pal()(length(unique(metadata$country_assessment))),  # a nice  color for each of the n countries
                             rep("darkgrey", length(unique(metadata$taxonomic_group)))), # grey for the n taxonomic groups
                    breaks=c(unique(metadata$country_assessment), 
                             unique(metadata$taxonomic_group))) +
  theme_sankey(base_size = 10) +
  xlab("")
  

```


How is the distribution of Ne / Nc data across countries and taxa?

Using alluvial:
```{r, out.width="700px", out.height="500px"}
library(alluvial)
# estimate frequencies for alluvial plot
foralluvial_1<-metadata_firstmulti %>% group_by(country_assessment, taxonomic_group, popsize_data) %>%
             summarise(n=n())
head(foralluvial_1)

## plot
# define colors
my_cols<- gg_color_hue(length(unique(foralluvial_1$country_assessment)))

# we need a vector of colors by country for each row of the dataset, so:
countries<-as.factor(foralluvial_1$country_assessment)
levels(countries)<-my_cols
countries<-as.vector(countries)
head(countries)

# plot
alluvial(foralluvial_1[,1:3], freq = foralluvial_1$n,
         col=countries, 
         blocks=FALSE,
         gap.width = 0.5,
         cex=.8, 
         xw = 0.1,
         cw = 0.2,
         border = NA)

```

Using ggsankey option 1
```{r, out.width="900px", out.height="600px"}
# transform data to how ggsankey wants it
df <- metadata_firstmulti %>%
  make_long(country_assessment, taxonomic_group, popsize_data)

# Sankey
ggplot(df, aes(x = x,
               next_x = next_x,
               node = node,
               next_node = next_node,
               fill = factor(node),
               label = node)) +
  geom_sankey(flow.alpha = 0.6, 
              show.legend = FALSE) +
  # manually set flow fill according to countries and popsize 
                      # a nice  color for each of the n countries for the first (left) part
  scale_fill_manual(values=c(scales::hue_pal()(length(unique(metadata_firstmulti$country_assessment))),  
                             # grey for the taxonomic groups
                              rep("darkgrey", length(unique(metadata_firstmulti$taxonomic_group))),
                             # three colors for popsize_data
                             c("darkolivegreen", "darkgoldenrod1", "brown3")), 
                    breaks=c(unique(metadata_firstmulti$country_assessment), 
                             unique(metadata_firstmulti$taxonomic_group),
                             unique(metadata_firstmulti$popsize_data))) +

  geom_sankey_label(size = 2, color = 1, fill = "white") +
  theme_sankey(base_size = 10) +
  xlab("")

```

Using ggsankey option 2
```{r, out.width="900px", out.height="600px"}
# transform data to how ggsankey wants it
df <- metadata_firstmulti %>%
  make_long(country_assessment, taxonomic_group, popsize_data)

# Sankey
ggplot(df, aes(x = x,
               next_x = next_x,
               node = node,
               next_node = next_node,
               fill = factor(node),
               label = node)) +
  geom_sankey(flow.alpha = 0.6, 
              show.legend = FALSE) +
  # manually set flow fill according to countries and popsize 
                      # a nice  color for each of the n countries for the first (left) part
  scale_fill_manual(values=c(scales::hue_pal()(length(unique(metadata_firstmulti$country_assessment))),  
                             # gradient of soft colors for taxonomic groups
                              cividis(length(unique(metadata_firstmulti$taxonomic_group))),
                             # traffic light for pop data
                             c("darkolivegreen", "darkgoldenrod1", "brown3")), 
                    breaks=c(unique(metadata_firstmulti$country_assessment), 
                             levels(as.factor(metadata_firstmulti$taxonomic_group)),
                             unique(metadata_firstmulti$popsize_data))) +

  geom_sankey_label(size = 2.5, color = "black", fill = "white") +
  theme_sankey(base_size = 10) +
  xlab("")

```



Taxonomic groups and IUCN status

Using alluvial:
```{r, out.width="900px", out.height="600px"}
library(alluvial)
# estimate frequencies for alluvial plot
foralluvial_1<-metadata_firstmulti %>% group_by(taxonomic_group, global_IUCN, popsize_data) %>%
             summarise(n=n())

## plot
# define colors according to IUCN categories
# check order of categories:
levels(as.factor(metadata_firstmulti$global_IUCN))

# create vector of colors accordingly:
my_cols<-c("brown2", "darkgrey", "darkorange", "darkgreen", "azure2", "green", "bisque1", "yellow")


# we need a vector of colors by iucn for each row of the dataset, so:
gIUCN<-as.factor(foralluvial_1$global_IUCN)
levels(gIUCN)<-my_cols
gIUCN<-as.vector(gIUCN)
head(gIUCN)

# plot
alluvial(foralluvial_1[,1:3], freq = foralluvial_1$n,
         col=gIUCN, 
         blocks="bookends",
         alpha = 0.6,
         gap.width = 0.4,
         cex=.75, 
         xw = 0.15,
         cw = 0.2,
         border = NA)

```

Using ggsankey

```{r, out.width="900px", out.height="600px"}
# transform data to how ggsankey wants it
df <- metadata %>%
  make_long(taxonomic_group, global_IUCN, popsize_data)


# Sankey
ggplot(df, aes(x = x,
               next_x = next_x,
               node = node,
               next_node = next_node,
               fill = factor(node),
               label = node)) +
  geom_sankey(flow.alpha = 0.6, 
              node.color = NA,
              show.legend = FALSE) +
  
    # manually set flow fill 
                       # gradient of soft colors for taxonomic groups
  scale_fill_manual(values= c(cividis(length(unique(metadata_firstmulti$taxonomic_group))),
                       # iucn color codes
                           c("brown2", "darkgrey", "darkorange", "darkgreen", "azure2", "green", "bisque1", "yellow"),
                     # traffic light for pop data
                           c("darkolivegreen", "darkgoldenrod1", "brown3")), 
                    breaks=c(levels(as.factor(metadata_firstmulti$taxonomic_group)), 
                             levels(as.factor(metadata_firstmulti$global_IUCN)),
                             unique(metadata_firstmulti$popsize_data))) +

  geom_sankey_label(size = 2, color = 1, fill = "white") +
  theme_sankey(base_size = 10) +
  xlab("")
```


## Estimate indicator 1

### Remember population size data could be obtained by different means

Population size data may come from different methods for each population within a single taxon. For example, some populations can have Ne estimates, other Nc and others a range. Examples:

```{r}
ind1_data %>%
  filter(taxon=="Alces alces") %>% 
  select(country_assessment, taxon, population, Name, Ne, NcRange)


ind1_data %>%
  filter(taxon=="Alces alces") %>% 
  select(country_assessment, taxon, population, Name, NcPoint, NcRange)

```

**QUESTION: should we create a "Ne_from_all_methods" variable with a Ne estimate regardless of the source? e.g. where Ne_from_all_methods = Ne AND Ne_from_all_methods = NcPoint(0.1) AND Ne_from_all_methods = 501 if NcRange==more_5000..**


Also, for some taxa there may be population size data for some populations, but not all. Therefore indicator 1 would be computed with less populations than the total number of populations. Example (see pop3, 4, 13, 15):

```{r}
ind1_data %>%
  filter(taxon=="Juniperus monticola") %>% 
  select(country_assessment, taxon, population, Name, Ne, NcPoint, NcRange)
```
We need to keep the former in mind for interpretation and discussion of how the indicator can change in future assessments if data becomes available for populations currently missing.


## Estimate indicator 2 (proportion of populations within species which are maintained)

Indicator 2 is the he proportion of populations within species which are maintained. This can be estimated based on the `n_extant_populations` and `n_extint_populations`, as follows:

```{r}
ind2_data$indicator2<- ind2_data$n_extant_populations / (ind2_data$n_extant_populations + ind2_data$n_extint_populations)
head(ind2_data$indicator2)
```



### Distribution of NA in indicator 2

We have NA because in some cases the number of extinct populations is unknown, therefore the above operation cannot be computed. 

Total records with NA in extant populations:
```{r}
sum(is.na(ind2_data$n_extant_populations))
```

Which are?
```{r}
ind2_data %>%
  filter(is.na(n_extant_populations)) %>%
    select(country_assessment, taxonomic_group, taxon, n_extant_populations, n_extint_populations)
```

Total taxa with NA in **extinct** populations:
```{r}
sum(is.na(ind2_data$n_extint_populations))
```

Do taxa with NA for extant also have NA for extinct?

```{r}
ind2_data$taxon[is.na(ind2_data$n_extant_populations)] %in% ind2_data$taxon[is.na(ind2_data$n_extint_populations)]
```

So out of the `r nrow(ind2_data)`, we have **`r sum(is.na(ind2_data$n_extint_populations))` records with NA in n_extinct** and **`r sum(is.na(ind2_data$n_extant_populations))` records with NA in n_extant**. Of them, `r sum(ind2_data$taxon[is.na(ind2_data$n_extant_populations)] %in% ind2_data$taxon[is.na(ind2_data$n_extint_populations)])` have NA in both n_extant and n_extinct.

**QUESTION: should we manually check that NA are correct in both extinct or extant pops? (the cleaning script only chekcs for 0, not NAs)**

So in total there are `r sum(is.na(ind2_data$indicator2))` records where there are NA in either n_extant or n_extinct, which is `r round(sum(is.na(ind2_data$indicator2))/nrow(ind2_data)*100, 2)`% of total number of records. Therefore when estimating indicator 2... **QUESTION: What should we do: A) we can’t estimate indicator 2 in those species, or B) we assume n_extinct = NA = 0, and therefore indicator 2 = 1.**

##### Plots!

By country
```{r}
ind2_data %>%
  ggplot(aes(x=country_assessment, fill=is.na(indicator2)))+
  geom_bar(position = "dodge") +
  coord_flip()
```

By taxonomic group
```{r}
ind2_data %>%
  ggplot(aes(x=taxonomic_group, fill=is.na(indicator2)))+
  geom_bar(position = "dodge") +
  coord_flip()
```


### Number of extanct populations.

See the distribution of the number of extant populations:

```{r}
ind2_data %>% 
  ggplot(aes(x=n_extant_populations)) +
  geom_density() + 
  ggtitle("histogram of extant populations")
```

Which taxa have more than 100 populations?
```{r}
ind2_data %>% 
  filter(n_extant_populations>100) %>%
  select(taxon, country_assessment, n_extant_populations)
```

Exclude outliers (>200 populations)
```{r}
ind2_data %>% 
  filter(n_extant_populations<200) %>%
  ggplot(aes(x=n_extant_populations)) +
  geom_density() + 
  ggtitle("Distribution of extant populations \nexcluding outliers (>200 pops)")

```

How does the number of populations vary by country? (excluding outliers: >200 pops)

```{r}
ind2_data %>% 
  filter(n_extant_populations<200) %>%
  ggplot(aes(x=country_assessment, y=n_extant_populations)) +
          geom_boxplot(aes(color=country_assessment)) +
  coord_flip() +
  theme_bw() +
  theme(panel.border = element_blank(), legend.position="none")


```

And by method to define populations? (excluding outliers: >200 pops)

```{r, out.width=900, out.height=500}
ind2_data %>% 
  filter(n_extant_populations<200) %>%
  ggplot(aes(x=defined_populations, y=n_extant_populations)) +
          geom_boxplot() +
  coord_flip() +
  theme_bw() +
  theme(panel.border = element_blank())

```
**QUESTION: How to account for different methods to deffine populations, and their combinations?**

### Distribution of multiassessments and single assesments
Some taxa were assessed more than once to account for, for example, different ways in how to delimit populations. Create a subset of them, excluding those records with missing data in indicator2 (due to missing data in n_pops). 

```{r}
#subset only with taxa assessed multiple times:
ind2_data_multi<-ind2_data %>% 
                          filter(multiassessment=="multiassessment") 
```

In total there are `r nrow(ind2_data_multi)` multiassessed records, of `r length(unique(ind2_data_multi$taxon))` taxa. Notice that this can include missing data in the number of populations, hence not allowing to estimate indicator 2.

To be able to visualize the missing data, the following plot changes NA to -1.
Variation in the number of extant populations by assessment

```{r, out.width=800, out.height=500}
# plot
ind2_data_multi %>% 
  mutate(n_extant_populations=ifelse(is.na(n_extant_populations), -1, n_extant_populations)) %>%
  ggplot(aes(x=taxon, y=n_extant_populations)) +
          geom_line(colour="darkgrey") + 
          geom_point(aes(color=country_assessment)) +
  xlab("") +
  coord_flip() +
  ggtitle("Variation in the number of extant populations, \nfor multiassessed taxa") +
  theme_bw() + 
  theme(legend.position = "bottom")
```

Same plot, but excluding Bombus terricola's massive variation:

```{r, out.width=800, out.height=500}
# plot
ind2_data_multi %>% 
  filter(taxon!="Bombus terricola") %>% 
  mutate(n_extant_populations=ifelse(is.na(n_extant_populations), -1, n_extant_populations)) %>%
  ggplot(aes(x=taxon, y=n_extant_populations)) +
          geom_line(colour="darkgrey") + 
          geom_point(aes(color=country_assessment)) +
  xlab("") +
  coord_flip() +
  ggtitle("Variation in the number of extant populations, \nfor multiassessed taxa") +
  theme_bw() + 
  theme(legend.position = "bottom")
```

Now for extinct populations (NA transformed as -1 for visualization purposes):

```{r, out.width=800, out.height=500}
# plot
ind2_data_multi %>% 
  mutate(n_extint_populations=ifelse(is.na(n_extint_populations), -1, n_extint_populations)) %>%
  ggplot(aes(x=taxon, y=n_extint_populations)) +
          geom_line(colour="darkgrey") + 
          geom_point(aes(color=country_assessment)) +
  xlab("") +
  coord_flip() +
  ggtitle("Variation in the number of extinct populations, \nfor multiassessed taxa") +
  theme_bw() + 
  theme(legend.position = "bottom")
```

See you later, Bombus terricola

```{r, out.width=800, out.height=500}
# plot
ind2_data_multi %>% 
  filter(taxon!="Bombus terricola") %>%
  mutate(n_extint_populations=ifelse(is.na(n_extint_populations), -1, n_extint_populations)) %>%
  ggplot(aes(x=taxon, y=n_extint_populations)) +
          geom_line(colour="darkgrey") + 
          geom_point(aes(color=country_assessment)) +
  xlab("") +
  coord_flip() +
  ggtitle("Variation in the number of extinct populations, \nfor multiassessed taxa") +
  theme_bw() + 
  theme(legend.position = "bottom")
```

This is how much the values of indicator2 vary within mutliassessed taxa (taxa names with no shown values mean they have missing data in the number of populations and hence indicator 2 can't be estimated):

```{r, out.width=800, out.height=500}

# plot
ind2_data_multi %>% 
  ggplot(aes(x=taxon, y=indicator2)) +
          geom_line(colour="darkgrey") + 
          geom_point(aes(color=country_assessment)) +
  xlab("") +
  coord_flip() +
  ggtitle("Variation in indicator 2, \nfor multiassessed taxa") +
  theme_bw() + 
  theme(legend.position = "bottom")

```

For exploratory purposes, unless otherwise stated differently, the analyses below will use a subset of the data including only taxa assessed a single time, plus the first record of those assessed multiple times.

```{r}
#subset keeping only taxa assessed a single time, plust the first record of those assessed multiple times.
ind2_data_firstmulti<-ind2_data[!duplicated(cbind(ind2_data$taxon, ind2_data$country_assessment)), ]

```


### Indicator 2 values distribution

Remember, for exploratory purposes, unless otherwise stated differently, the analyses below will use a subset of the data including only taxa assessed a single time, plus the first record of those assessed multiple times.


For the taxa that do have data, this is how the values of indicator2 are distributed: 

```{r}
hist(ind2_data_firstmulti$indicator2)
```

Visualizing by country

```{r}
# get sample size by desired category

sample_size <- ind2_data_firstmulti %>%
                    filter(!is.na(indicator2)) %>% 
                    group_by(country_assessment) %>% summarize(num=n())

# plot
ind2_data_firstmulti %>% 
  # add sampling size 
  left_join(sample_size) %>%
  mutate(myaxis = paste0(country_assessment, " (n= ", num, ")")) %>%

  # plot
  ggplot(aes(x=myaxis, y=indicator2, fill=country_assessment)) +
  geom_violin(width= 1, linewidth = 0)  +
  geom_jitter(size=.5, width = 0.1) +
  xlab("") +
  coord_flip() +
  theme_bw() +
  theme(panel.border = element_blank(), legend.position="none")

```

Visualizing by taxonomic group:

```{r}
# get sample size by desired category

sample_size <- ind2_data_firstmulti %>%
                    filter(!is.na(indicator2)) %>% 
                    group_by(taxonomic_group) %>% summarize(num=n())

# plot
ind2_data_firstmulti %>% 
  # add sampling size 
  left_join(sample_size) %>%
  mutate(myaxis = paste0(taxonomic_group, " (n= ", num, ")")) %>%
  
  #plot
ggplot(aes(x=myaxis, y=indicator2, fill=taxonomic_group), color=NA) +
      geom_violin(width=2, linewidth = 0)  +
      geom_jitter(size=.5, width = 0.1, color="brown") +
      xlab("") +
      coord_flip() +
      scale_fill_manual(values= c(cividis(length(unique(ind2_data_firstmulti$taxonomic_group)))),
                    breaks=c(levels(as.factor(ind2_data_firstmulti$taxonomic_group)))) +
      theme_bw() +
      theme(panel.border = element_blank(), legend.position="none")
      
```

Visualizing by IUCN:

```{r}

# add IUCN data form metadata to ind2
ind2_data_firstmulti$global_IUCN <- metadata_firstmulti$global_IUCN

# get sample size by desired category
sample_size <- ind2_data_firstmulti %>%
                    filter(!is.na(indicator2)) %>% 
                    group_by(global_IUCN) %>% summarize(num=n())

# plot
ind2_data_firstmulti %>% 
  # add sampling size 
  left_join(sample_size) %>%
  mutate(myaxis = paste0(global_IUCN, " (n= ", num, ")")) %>%

  # plot
  ggplot(aes(x=myaxis, y=indicator2, fill=global_IUCN)) +
      geom_violin(width=1, linewidth = 0)  +
      geom_jitter(size=.5, width = 0.1) +
      xlab("") +
      coord_flip() +
      scale_fill_manual(values= c("brown2", "darkgrey", "darkorange", "darkgreen", "azure2", "green", "bisque1", "yellow"), # iucn color codes
                    breaks=c(levels(as.factor(ind2_data_firstmulti$global_IUCN)))) +
      theme_bw() +
      theme(panel.border = element_blank(), legend.position="none")
      
```

Does the number of populations affects the value of indicator 2? (excluding outliers: >200 pops)

```{r}
ind2_data_firstmulti %>%
  # filter outliers with too many pops
  filter(n_extant_populations<200) %>%
  
  # plot
    ggplot(aes(x=n_extant_populations, y=indicator2)) +
    geom_point()

```
Same, colouring by country


```{r}
ind2_data_firstmulti %>%
  # filter outliers with too many pops
  filter(n_extant_populations<200) %>%
  
  # plot
    ggplot(aes(x=n_extant_populations, y=indicator2, color=country_assessment)) +
    geom_point() +
    theme_bw()

```

By global IUCN risk

```{r}
ind2_data_firstmulti %>%
  # filter outliers with too many pops
  filter(n_extant_populations<200) %>%
  
  # plot
    ggplot(aes(x=n_extant_populations, y=indicator2, color=global_IUCN)) +
    geom_point() + 
        scale_color_manual(values= c("brown2", "darkgrey", "darkorange", "darkgreen", "azure2", "green", "bisque1", "yellow"), # iucn color codes
                           breaks=c(levels(as.factor(ind2_data_firstmulti$global_IUCN)))) +
  theme_bw()


```

## Estimate indicator 3 (number of taxa with genetic monitoring squemes)

Indicator 3 refers to the number (count) of taxa by country in which genetic monitoring is occurring. This is stored in the variable `temp_gen_monitoring` as a "yes/no" answer for each taxon, so to estimate the indicator, we only need to count how many said "yes", keeping only one of the records when the taxon was multiassessed:

```{r}
indicator3<-ind3_data %>%
                 # keep only one record if the taxon was assessed more than once within the country
                 select(country_assessment, taxon, temp_gen_monitoring) %>%
                 filter(!duplicated(.)) %>%

                 # count "yes" in tem_gen_monitoring by country
                 filter(temp_gen_monitoring=="yes") %>%
                 group_by(country_assessment) %>%
                 summarise(n_taxon_gen_monitoring= n())
```

Plot indicator 3 by country:

```{r}
indicator3 %>%
  ggplot(aes(x=country_assessment, y=n_taxon_gen_monitoring)) +
  geom_bar(stat="identity")
```

Relatively few taxa have genetic monitoring, but many have some sort of genetic study. Let's check that, but first subset the ind3_data keeping only taxa assessed a single time, plust the first record of those assessed multiple times.
```{r}
#subset keeping only taxa assessed a single time, plust the first record of those assessed multiple times.
ind3_data_firstmulti<-ind3_data[!duplicated(cbind(ind3_data$taxon, ind3_data$country_assessment)), ]
```

Sankey plot of genetic studies

```{r}
# transform data to how ggsankey wants it
df <- ind3_data_firstmulti %>%
  make_long(country_assessment, temp_gen_monitoring, gen_studies)

# plot
ggplot(df, aes(x = x,
               next_x = next_x,
               node = node,
               next_node = next_node,
               fill = factor(node),
               label = node)) +
  geom_sankey(flow.alpha = 0.5, 
              show.legend = FALSE) +
  geom_sankey_label(size = 2.5, color = "black", fill = "white") +
  theme_sankey(base_size = 10) +

    # manually set flow fill according to desired color
                            # countries
  scale_fill_manual(values=c(scales::hue_pal()(length(unique(ind3_data_firstmulti$country_assessment))),  
                             # traffic light for monitoring
                             c("darkolivegreen", "brown3", "darkgrey"),
                             # nice soft colors for gen_studies
                             c("grey50", "grey35", "grey50", "brown3")),
                              
                    breaks=c(unique(ind3_data_firstmulti$country_assessment),
                             unique(ind3_data_firstmulti$temp_gen_monitoring),
                             unique(ind3_data_firstmulti$gen_studies))) +
  
  xlab("")


```

Similar, but alluvial to show data colloring the flow by country
```{r}
# format data as needed
foralluvial_2<-ind3_data_firstmulti %>% group_by(country_assessment, temp_gen_monitoring, gen_studies) %>%
             summarise(n=n())

# define colors
my_cols<- gg_color_hue(length(unique(foralluvial_2$country_assessment)))
# we need a vector of colors by country for each row of the dataset, so:
countries<-as.factor(foralluvial_2$country_assessment)
levels(countries)<-my_cols
countries<-as.vector(countries)

# plot
alluvial(foralluvial_2[,1:3], freq = foralluvial_2$n,
         col=countries,  
         blocks=FALSE,
         gap.width = 0.5,
         cex=.8, 
         xw = 0.1,
         cw = 0.2,
         border = NA)


```



## Session Info for reproducibility purposes:

```{r}
sessionInfo()
```


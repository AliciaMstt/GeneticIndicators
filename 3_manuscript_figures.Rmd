---
title: "Main figures and analyses for the manuscript"
output:
  html_document:
    df_print: paged
    toc: true
date: "2023-08-03"
---

This notebook estimates the indicators based on the raw data and perfomrs the main analyses and figures used in the manuscript of the multicountry paper. The input is the "clean kobo output" that was first cleaned by `1.2_cleaning`.

## Packages and functions

Load required libraries:

```{r, warning=FALSE, message=FALSE}
library(tidyr)
library(dplyr)
library(utile.tools)
library(stringr)
library(ggplot2)
library(ggsankey)
library(alluvial)
library(viridis)
library(cowplot)
```

Load required functions. These custom fuctions are available at: https://github.com/AliciaMstt/GeneticIndicators

```{r source}
source("get_indicator1_data.R")
source("get_indicator2_data.R")
source("get_indicator3_data.R")
source("get_metadata.R")
source("transform_to_Ne.R")
source("estimate_indicator1.R")
```

Other custom functions:
```{r custom_funs}
### not in
'%!in%' <- function(x,y)!('%in%'(x,y))


#' Duplicates data to create additional facet. Thanks to https://stackoverflow.com/questions/18933575/easily-add-an-all-facet-to-facet-wrap-in-ggplot2
#' @param df a dataframe
#' @param col the name of facet column
#'  
CreateAllFacet <- function(df, col){
  df$facet <- df[[col]]
  temp <- df
  temp$facet <- "all"
  merged <-rbind(temp, df)

  # ensure the facet value is a factor
  merged[[col]] <- as.factor(merged[[col]])

  return(merged)
}
```

Custom colors:
```{r custom colors}
## IUCN official colors
# Assuming order of levels is: "re", "cr", "en", "vu", "nt", "lc", "dd", "not_assessed", "unknown" (for regional, and w/o "re" for global). Make sure to change the levels to that order before plotting.
IUCNcolors<-c("brown2", "darkorange", "yellow", "green", "darkgreen", "darkgrey", "azure2", "bisque1")
IUCNcolors_regional<-c("darkorchid2", "brown2", "darkorange", "yellow", "green", "darkgreen", "darkgrey", "azure2", "bisque1")

## nice soft ramp for taxonomic groups
taxoncolors<-cividis(12) # same than using cividis(length(levels(as.factor(metadata$taxonomic_group))))

## Colors for simplified methods to define populations 
# assuming the levels (see how this was created in the section "Simplify combinations of methods to define populations"): of running levels(as.factor(ind2_data$defined_populations_simplified))

# get a set of colors to highlight genetic and geographic with similar colors

simplifiedmethods_colors<-c("#b34656", #"adaptive_traits management_units"
                            "#b34656", # "management_units" 
                            "#7f611b", # "eco_biogeo_proxies"
                            "#668cd1", # "genetic_clusters"     
                            "#668cd1", # "genetic_clusters eco_biogeo_proxies"     
                            "#45c097", # "genetic_clusters geographic_boundaries"  
                            "#d4b43e", # "geographic_boundaries"                   
                            "#d4b43e", # "geographic_boundaries adaptive_traits"
                            "#d4b43e", # "geographic_boundaries eco_biogeo_proxies"
                            "#d4b43e", # "geographic_boundaries management_units"  
                            "#be72c9", # "low_freq_combinations" 
                            "#be72c9")# "other" 
  
```

## Get data 
Get indicators and metadata data from clean kobo output
```{r, echo=TRUE}
# Get data:
kobo_clean<-read.csv(file="kobo_output_clean.csv", header=TRUE)

# Extract indicator 1 data from kobo output, show most relevant columns
ind1_data<-get_indicator1_data(kobo_output=kobo_clean)
head(ind1_data[,c(1:3, 12:14)])

# Extract indicator 2 data from kobo output, show most relevant columns
ind2_data<-get_indicator2_data(kobo_output=kobo_clean)
head(ind2_data[,c(1:3, 9:10,13)])

# Extract indicator 3 data from kobo output, show most relevant columns
ind3_data<-get_indicator3_data(kobo_output=kobo_clean)
head(ind3_data[,c(1:3, 9:11)])

# extract metadata, show most relevant columns
metadata<-get_metadata(kobo_output=kobo_clean)
head(metadata[,c(1:3, 12, 25,26, 64)])
```

## A note on multiassesments
Some taxa were assessed twice or more times, for example to account for uncertainty on how to divide populations. This information is stored in variable `multiassessment` of the metadata (created by `get_metadata()`). An example of taxa with multiple assessments:

```{r}
metadata %>%
filter(multiassessment=="multiassessment")  %>%
  select(taxonomic_group, taxon, country_assessment, multiassessment) %>%
  arrange(taxon, country_assessment) %>%
  head()
  
```
## Estimate indicators

### Indicator 1 (proportion of populations with Ne >500):

Show most relevant columns of indicator 1 data
```{r}
head(ind1_data[,c(1:3, 12:14)])

```

Remember what the function to transform NcRange and NcPoint data into Ne does:
```{r}
# check what the custom funciton does
transform_to_Ne
```

Use function to get Ne data from NcRange or NcPoint data, and their combination (Ne estimated from Ne if Ne is available, otherwise, from Nc)

```{r}
ind1_data<-transform_to_Ne(ind1_data = ind1_data)
```

Remember what the function to estimate indicator 1 does:
```{r}
# check what the custom function does
estimate_indicator1
```

**Now estimate indicator 1 :)**

```{r}
indicator1<-estimate_indicator1(ind1_data = ind1_data)
```

### Indicator 2 (proportion of populations within species which are maintained)

Indicator 2 is the he proportion of populations within species which are maintained. This can be estimated based on the `n_extant_populations` and `n_extint_populations`, as follows:

```{r}
ind2_data$indicator2<- ind2_data$n_extant_populations / (ind2_data$n_extant_populations + ind2_data$n_extint_populations)
head(ind2_data$indicator2)
```

### Indicator 3 (number of taxa with genetic monitoring squemes)

Indicator 3 refers to the number (count) of taxa by country in which genetic monitoring is occurring. This is stored in the variable `temp_gen_monitoring` as a "yes/no" answer for each taxon, so to estimate the indicator, we only need to count how many said "yes", keeping only one of the records when the taxon was multiassessed:

```{r}
indicator3<-ind3_data %>%
                 # keep only one record if the taxon was assessed more than once within the country
                 select(country_assessment, taxon, temp_gen_monitoring) %>%
                 filter(!duplicated(.)) %>%

                 # count "yes" in tem_gen_monitoring by country
                 filter(temp_gen_monitoring=="yes") %>%
                 group_by(country_assessment) %>%
                 summarise(n_taxon_gen_monitoring= n())
```

### Join indicators and metadata in a single table

It could be useful to have the estimated indicator and the metadata in a single large table.
```{r}
indicators_full<-left_join(metadata, indicator1) %>% 
                     left_join(ind2_data) %>% 
                     left_join(ind3_data)
```

### Save indicators data
Save indicators data and metadata to csv files, useful for analyses outside R.

```{r}
# save processed data
write.csv(ind1_data, "ind1_data.csv", row.names = FALSE, fileEncoding = "UTF-8")
write.csv(indicators_full, "indicators_full.csv", row.names = FALSE, fileEncoding = "UTF-8")
write.csv(ind2_data, "ind2_data.csv", row.names = FALSE, fileEncoding = "UTF-8")
write.csv(ind3_data, "ind3_data.csv", row.names = FALSE, fileEncoding = "UTF-8")
write.csv(metadata, "metadata.csv", row.names = FALSE, fileEncoding = "UTF-8")

```


## Change country name to nicer labels

To have nice levels in the plots we will change the way country names are written: 

```{r nice country names}
# make factor
metadata$country_assessment<-as.factor(metadata$country_assessment)
indicators_full$country_assessment<-as.factor(indicators_full$country_assessment)
ind2_data$country_assessment<-as.factor(ind2_data$country_assessment)
ind1_data$country_assessment<-as.factor(ind1_data$country_assessment)
indicator1$country_assessment<-as.factor(indicator1$country_assessment)

# original levels
levels(metadata$country_assessment)

# change
levels(metadata$country_assessment)<-c("Australia", "Belgium", "Colombia", "France", "Japan", "Mexico", "S. Africa", "Sweden", "US")
levels(ind1_data$country_assessment)<-c("Australia", "Belgium", "Colombia", "France", "Japan", "Mexico", "S. Africa", "Sweden", "US")
levels(ind2_data$country_assessment)<-c("Australia", "Belgium", "Colombia", "France", "Japan", "Mexico", "S. Africa", "Sweden", "US")
levels(indicator1$country_assessment)<-c("Australia", "Belgium", "Colombia", "France", "Japan", "Mexico", "S. Africa", "Sweden", "US")

```


## Simplify combinations of methods to define populations

The methods used to define populations come from a check box question were one or more of the following categories can be selected: genetic_clusters, geographic_boundaries, eco_biogeo_proxies, adaptive_traits, management_units, other. As a consequence any combination of the former can be possible. Leading to the following frequency table:

```{r}
table(ind2_data$defined_populations)
```

It is hard to group the above methods, so we will keep the original groups with n >=19 in the above list, and tag the combinations that appear few times as as "low_freq_combinations".

Which groups have n>=19?
```{r}
x<-as.data.frame(table(ind2_data$defined_populations)[table(ind2_data$defined_populations) >= 19])
colnames(x)[1]<-"method"

x

```
We can add this new column to the metadata and indicator 2 data:

```{r} 
### for ind2_data
ind2_data<- ind2_data %>% 
  mutate(defined_populations_simplified = case_when(
         # if the method is in the list of methods n>=19 then keep it
         defined_populations %in% x$method ~ defined_populations,
         TRUE ~ "low_freq_combinations"))


### for meta
metadata<- metadata %>% 
  mutate(defined_populations_simplified = case_when(
         # if the method is in the list of methods n>=19 then keep it
         defined_populations %in% x$method ~ defined_populations,
         TRUE ~ "low_freq_combinations"))
         
```


Check n for simplified methods:

```{r}
table(ind2_data$defined_populations_simplified)
```

Table of equivalences:

```{r}
ind2_data %>% 
       select(defined_populations, defined_populations_simplified) %>% 
       filter(!duplicated(defined_populations))
```

Create nicer names for ploting
```{r}
# original method names
levels(as.factor(ind2_data$defined_populations_simplified))

# nice methods names in original order
nice_names_or <- c("adaptive traits & management units",
                    "eco- biogeographic proxies",
                   "genetic clusters",
                   "genetic clusters & eco- biogeographic proxies",
                   "genetic clusters & geographic boundaries",
                   "geographic boundaries",
                   "geographic boundaries & adaptive traits",
                   "geographic boundaries & eco- biogeographic proxies",
                   "geographic boundaries & management units",
                   "low frequency combinations",
                   "management units",
                   "others")

# nice names in better order for plotting
nice_names <- c("adaptive traits & management units",
                 "management units",
                  "eco- biogeographic proxies",
                   "genetic clusters",
                   "genetic clusters & eco- biogeographic proxies",
                   "genetic clusters & geographic boundaries",
                   "geographic boundaries",
                   "geographic boundaries & adaptive traits",
                   "geographic boundaries & eco- biogeographic proxies",
                   "geographic boundaries & management units",
                   "low frequency combinations",
                   "others")


### add them
## ind2
ind2_data$defined_populations_nicenames<-as.factor(ind2_data$defined_populations_simplified)
# add new nice names
levels(ind2_data$defined_populations_nicenames)<-nice_names_or
# change to desired order
ind2_data$defined_populations_nicenames<-factor(ind2_data$defined_populations_nicenames, 
                                                levels=nice_names)

# metadata
metadata$defined_populations_nicenames<-as.factor(metadata$defined_populations_simplified)
levels(metadata$defined_populations_nicenames)<-nice_names_or
metadata$defined_populations_nicenames<-factor(metadata$defined_populations_nicenames, 
                                                levels=nice_names)

#check names match
select(metadata, defined_populations_nicenames, defined_populations_simplified)
```


## General description of records and taxa assessed by country

Records by country, including taxa assessed more than once (see below for details on this)

```{r  taxa by country, out.width="700px", out.height="400px"}
ggplot(metadata, aes(x=country_assessment)) + 
  geom_bar(stat = "count") +
  xlab("") +
  ggtitle("Number of taxa assessed by country, including taxa assed more than once") +
  theme_light()

```

To explore what kind of taxa countries assessed regardless of if they assessed them once or more, lets create a dataset keeping all single assessed taxa, plus only the first assessment for taxa assessed multiple times. 

```{r}
# object with single assessed taxa, plus only the first assessment for taxa assessed multiple times
metadata_firstmulti<-metadata[!duplicated(cbind(metadata$taxon, metadata$country_assessment)), ]

```

How many taxa were assessed (i.e. counting only once taxa that were assessed multiple times)?
```{r}
# how many?
nrow(metadata_firstmulti)
```

Plot taxa assessed excluding duplicates, i.e. the real number of taxa assessed:

```{r, out.width="700px", out.height="400px"}
ggplot(metadata_firstmulti, aes(x=country_assessment)) + 
  geom_bar(stat = "count") +
  xlab("") +
  ggtitle("Number of taxa assessed by country") +
  theme_light()

```

Of which countries and taxonomic groups are the taxa that were assessed more than once?
```{r multiassessed}
metadata_firstmulti %>% # we use the _unique dataset so that multiassesed records are counted only once
        filter(multiassessment=="multiassessment") %>%

ggplot(aes(x=taxonomic_group, fill=country_assessment)) + 
  geom_bar(stat = "count") +
  theme(axis.text.x = element_text(angle = 45)) +
  labs(fill="Country") +
  xlab("") +
  ggtitle("Number of taxa assessed more than once") +
  theme_light()


```

## Population size data (Has Nc or Ne? what type of Nc?)

### Population size data availability by country
Countries have population size data (Nc or Ne) regardless of the taxonomic group.

```{r}
ggplot(metadata, aes(x=taxonomic_group, fill=popsize_data)) + 
  geom_bar(stat = "count") +
  coord_flip() +
  facet_wrap(~country_assessment, ncol = 5) +
  scale_fill_manual(values=c("#2ca02c", "#1f77b4", "grey80"),
                    breaks=c("yes", "data_for_species", "insuff_data_species"),
                    labels=c("Population level", "Species or subspecies level", "Insufficient data")) +
  labs(fill="Population size data availability",
       x="",
       y="Number of taxa (including records of taxa assessed more than once)") +
  theme_light() +
  theme(panel.border = element_blank(), legend.position="top")
  
```

Same plot but including a panel for the entire dataset:

```{r}
## Duplicate data with an additional column "facet"

df<-CreateAllFacet(metadata, "country_assessment")

# order with "all" as last
df$facet <- factor(df$facet, levels=c("Australia", "Belgium", "Colombia", "France", "Japan", "Mexico", "S. Africa", "Sweden", "US", "all"))

# Plot
ggplot(df, aes(x=taxonomic_group, fill=popsize_data)) + 
  geom_bar(stat = "count") +
  coord_flip() +
  facet_wrap(~facet, ncol = 5, scales="free_x") +
  scale_fill_manual(values=c("#2ca02c", "#1f77b4", "grey80"),
                    breaks=c("yes", "data_for_species", "insuff_data_species"),
                    labels=c("Population level", "Species or subspecies level", "Insufficient data")) +  labs(fill="Population size data availability",
       x="",
       y="Number of taxa (including records of taxa assessed more than once)") +
  theme_light() +
  theme(panel.border = element_blank(), legend.position="top")

```

Population size data availability in the entire dataset:
```{r}
ggplot(metadata, aes(x=taxonomic_group, fill=popsize_data)) + 
  geom_bar(stat = "count") +
  coord_flip() +
  scale_fill_manual(values=c("#1f77b4", "grey80", "#2ca02c"),
                    breaks=c(levels(as.factor(metadata$popsize_data))),
                                        labels=c("Species level or subspecies level", "Insufficient data", "Population level")) +
  labs(fill="Population size data availability",
       x="",
       y="Number of taxa (including records of taxa assessed more than once)") +
  theme_light() +
  theme(legend.position="right")
```


### Ne data yes or not? & Type of Nc data

Ne available by taxa?
```{r}
p1<- metadata %>% 
  filter(!is.na(ne_pops_exists)) %>% 
  filter(ne_pops_exists!="other_genetic_info") %>%
    ggplot(aes(x=country_assessment, fill=ne_pops_exists)) + 
  geom_bar() +
scale_fill_manual(labels=c("no", "yes"),
                      breaks=c("no_genetic_data", "ne_available"),
                      values=c("#ff7f0e", "#2ca02c")) +
xlab("") +
ylab("Number of taxa") +
labs(fill="Ne available \n(from genetic data)")  +
theme_light() +
theme(text = element_text(size = 14), legend.position = "right", panel.border = element_blank())

p1

```

Nc data available by taxa?
```{r}
p2<-metadata %>%
  filter(!is.na(nc_pops_exists)) %>%
    ggplot(aes(x=country_assessment, fill=nc_pops_exists)) +
    geom_bar() +
    scale_fill_manual(values=c("#ff7f0e", "#2ca02c")) + 
    labs(fill="Nc available") +
    xlab("") +
    ylab("Number of taxa") +
    theme_light() +
    theme(text = element_text(size = 14), legend.position = "right", panel.border = element_blank())
p2
```


What kind of Nc data?
```{r}
p3<-ind1_data %>%
  filter(!is.na(NcType)) %>%
  ggplot(aes(x=country_assessment, fill=NcType))+
  geom_bar(position = "dodge") +
  scale_fill_manual(labels=c("Point", "Range \nor qualitative", "Unknown"),
                      breaks=c("Nc_point", "Nc_range", "unknown"),
                      values=c("#0072B2", "#E69F00", "grey80")) +
  xlab("") +
  ylab("Number of populations") +
  labs(fill="Type of Nc data \nby population") +
  theme_light() +
  theme(text = element_text(size = 14), legend.position = "right", panel.border = element_blank())
p3
 
```

Distribution of Nc, Ne and types of Ne in a single figure with 3 panels:


```{r, out.width="1000px", out.height="350px"}
# plot
plot_grid(p1, p2, p3, ncol=1, rel_heights = c(1,1,1.3), rel_widths = c(1,1,1.3), align = "v", labels=c("a)", "b)", "c)"), vjust = .7)  
```

**Same than above, but using percentages instead of count data**

Ne available by taxa?
```{r}
p1.1<- metadata %>% 
  filter(!is.na(ne_pops_exists)) %>% 
  filter(ne_pops_exists!="other_genetic_info") %>%
    ggplot(aes(x=country_assessment, fill=ne_pops_exists)) + 
  geom_bar(position="fill") +
scale_fill_manual(labels=c("no", "yes"),
                      breaks=c("no_genetic_data", "ne_available"),
                      values=c("#ff7f0e", "#2ca02c")) +
xlab("") +
ylab("Proportion of taxa") +
labs(fill="Ne available \n(from genetic data)")  +
theme_light() +
theme(text = element_text(size = 14), legend.position = "right", panel.border = element_blank())

p1.1

```

Nc available?
```{r}
p2.1<-metadata %>%
  filter(!is.na(nc_pops_exists)) %>%
    ggplot(aes(x=country_assessment, fill=nc_pops_exists)) +
    geom_bar(position = "fill") +
    scale_fill_manual(values=c("#ff7f0e", "#2ca02c")) + 
    labs(fill="Nc available") +
    xlab("") +
    ylab("Proportion of taxa") +
    theme_light() +
    theme(text = element_text(size = 14), legend.position = "right", panel.border = element_blank())
p2.1
```


What kind of Nc data?
```{r}
p3.1<-ind1_data %>%
  filter(!is.na(NcType)) %>%
  ggplot(aes(x=country_assessment, fill=NcType))+
  geom_bar(position = "fill") +
  scale_fill_manual(labels=c("Point", "Range \nor qualitative", "Unknown"),
                      breaks=c("Nc_point", "Nc_range", "unknown"),
                      values=c("#0072B2", "#E69F00", "grey80")) +
  xlab("") +
  ylab("Proportion of populations") +
  labs(fill="Type of Nc data \nby population") +
  theme_light() +
  theme(text = element_text(size = 14), legend.position = "right", panel.border = element_blank())
p3.1
 
```

Distribution of Nc, Ne and types of Ne in a single figure with 3 panels and proportions instead of count:


```{r, out.width="1000px", out.height="350px"}
# plot
plot_grid(p1.1, p2.1, p3.1, ncol=1, rel_widths = c(1,1,1), align = "v", labels=c("a)", "b)", "c)"), vjust = .7)  
```

Distribution of Nc, Ne and types of Ne in a single figure with 3 panels, using count for a & b, and proportions for c:


```{r, out.width="1000px", out.height="350px"}
# plot
plot_grid(p1, p2, p3.1, ncol=1, rel_widths = c(1,1,1), align = "v", labels=c("a)", "b)", "c)"), vjust = .7)  
```

## Method to define populations used by country (alluvial)

Reformat data
```{r}
select(metadata, defined_populations_nicenames, defined_populations_simplified)


# reformat data
foralluvial<-metadata %>% group_by(country_assessment, defined_populations_nicenames, taxonomic_group) %>%
             summarise(n=n()) 

# define colors
my_cols<- simplifiedmethods_colors

# we need a vector of colors by country for each row of the dataset, so:
methodspop<-as.factor(foralluvial$defined_populations_nicenames)
levels(methodspop)<-my_cols
methodspop<-as.vector(methodspop)
head(methodspop)
```

Plot
```{r}
# plot
alluvial(foralluvial[,1:3], freq = foralluvial$n,
         col=methodspop, 
         blocks=FALSE,
         gap.width = 0.5,
         cex=.8, 
         xw = 0.1,
         cw = 0.2,
         border = NA,
         alpha = .7)

```


## Effect of method used to define populations on number of populations and indicator 2 

### Number of mantained populations by country and method

Plot Number of mantained populations by country and method

```{r}
ind2_data %>% 
  filter(n_extant_populations<500) %>% # filter outliers
  # order countries vertically by similar number of pops
  mutate(country_assessment = factor(country_assessment, 
                                     levels=c("Colombia", "Australia", "Belgium",
                                               "Mexico", "France", "US", 
                                               "S. Africa", "Japan", "Sweden"))) %>%
  ggplot(aes(x=defined_populations_nicenames, y=n_extant_populations, 
             fill=defined_populations_nicenames, color=defined_populations_nicenames)) +
          geom_boxplot() +
          geom_jitter(size=.3, width = 0.1, color="black") +
  coord_flip() +
  facet_wrap(country_assessment ~ ., nrow=3, scales="free_x") +
  xlab("")  +
  ylab("Number of mantained populations") +
  scale_fill_manual(values=alpha(simplifiedmethods_colors, .3),
                    breaks=levels(as.factor(ind2_data$defined_populations_nicenames))) +
  scale_color_manual(values=simplifiedmethods_colors,
                    breaks=levels(as.factor(ind2_data$defined_populations_nicenames))) +
  scale_x_discrete(limits=rev) +
  theme_light() +
  theme(panel.border = element_blank(), legend.position="none",
        text = element_text(size = 15)) 



levels(ind2_data$country_assessment)
```

### Number of mantained populations by method

Plot number of populations by method
```{r, out.height="500px", out.width="1064px"}
# Prepare data for plot with nice labels:
# sample size of TOTAL populations
sample_size <- ind2_data %>%
                    filter(!is.na(indicator2)) %>% 
                    group_by(defined_populations_nicenames) %>% summarize(num=n())

# custom axis
## new dataframe
df<-ind2_data %>% 
  filter(n_extant_populations<500) %>%
    # add sampling size 
  left_join(sample_size) %>%
  mutate(myaxis = paste0(defined_populations_nicenames, " (n= ", num, ")")) %>%
#myaxis needs levels in the same order than defined_populations_nicenames
  mutate(myaxis = factor(myaxis, 
                  levels=levels(as.factor(myaxis))[c(1,11,2:10,12)])) # reorders levels


# plot for number of pops
  p1<- df %>%
  ggplot(aes(x=myaxis, y=n_extant_populations, color=defined_populations_nicenames,
                                               fill=defined_populations_nicenames)) +
          geom_boxplot() + xlab("") + ylab("Number of mantained populations") +
          geom_jitter(size=.4, width = 0.1, color="black") +
  coord_flip() +
  theme_light() +
  theme(panel.border = element_blank(), legend.position="none",
        plot.margin = unit(c(0, 0, 0, 0), "cm")) + # this is used to decrease the space between plots
  scale_color_manual(values=simplifiedmethods_colors,
                    breaks=levels(as.factor(ind2_data$defined_populations_nicenames))) +
  scale_fill_manual(values=alpha(simplifiedmethods_colors, 0.3),
                    breaks=levels(as.factor(ind2_data$defined_populations_nicenames))) +
  scale_x_discrete(limits=rev) +  
  theme(text = element_text(size = 13))
p1
```

Prepare data for ANOVA:
```{r}
# subset data without massive outlier
ind2_data_anova<- ind2_data %>% 
                         filter(n_extant_populations<1000)

# summary of n per variable
table(ind2_data_anova$defined_populations_simplified)
```

One way ANOVA on the effect of the methods to define populations on the number of populations

```{r}
# One way ANOVA method
res.anova.extant<-aov(n_extant_populations ~ defined_populations_simplified, data=ind2_data_anova)
res.anova.extant
```

Summary:
```{r}
summary(res.anova.extant)
```

Check for pairs that are statistically different (Tukey Honest Significant Differences, p < 0.05):
```{r}
# only padj < 0.05
x<-TukeyHSD(res.anova.extant)
x<-as.data.frame(x[[1]])
x[x$`p adj`<0.05, ]
```


### Indicator 2 by method

Plot

```{r}
# Prepare data for plot with nice labels:
# sample size of TOTAL populations
sample_size <- ind2_data %>%
                    filter(!is.na(indicator2)) %>% 
                    group_by(defined_populations_nicenames) %>% summarize(num=n())

# custom axis
## new dataframe
df<-ind2_data %>% 
  filter(n_extant_populations<500) %>%
    # add sampling size 
  left_join(sample_size) %>%
  mutate(myaxis = paste0(defined_populations_nicenames, " (n= ", num, ")")) %>%
#myaxis needs levels in the same order than defined_populations_nicenames
  mutate(myaxis = factor(myaxis, 
                  levels=levels(as.factor(myaxis))[c(1,11,2:10,12)])) # reorders levels



## plot for indicator 2
p2<- df %>%
  filter(n_extant_populations<500) %>%
  ggplot(aes(x=myaxis, y=indicator2, color=defined_populations_simplified,    
                                     fill=defined_populations_simplified)) +
          geom_boxplot() + xlab("") + ylab("Indicator 2") +
          geom_jitter(size=.4, width = 0.1, color="black") +
  coord_flip() +
  theme_light() +
  theme(panel.border = element_blank(), legend.position="none",
        plot.margin = unit(c(0, 0, 0, 0), "cm")) + # this is used to decrease the space between plots) 
  scale_fill_manual(values=alpha(simplifiedmethods_colors, 0.3),
                    breaks=levels(as.factor(ind2_data$defined_populations_simplified))) +
  scale_color_manual(values=simplifiedmethods_colors,
                    breaks=levels(as.factor(ind2_data$defined_populations_simplified))) +
  scale_x_discrete(limits=rev) +
  theme(text = element_text(size = 13))
p2

```

Prepare data
```{r}
# subset data without massive outlier
ind2_data_anova<- ind2_data %>% 
  filter(indicator2<1000)

# summary of n per variable
table(ind2_data_anova$defined_populations_simplified)
```

One way ANOVA 
```{r}
# One way ANOVA method
res.anova.indicator2<-aov(indicator2 ~ defined_populations_simplified, data=ind2_data_anova)
summary(res.anova.indicator2)
```

Summary:

```{r}
summary(res.anova.indicator2)
```


Check for pairs that are statistically different (Tukey Honest Significant Differences, p < 0.05):
```{r}
# only padj < 0.05
x<-TukeyHSD(res.anova.indicator2)
x<-as.data.frame(x[[1]])
x[x$`p adj`<0.05, ]
```

### Number of pops vs indicator2

Scatter plot of indicator2 and extant pops
```{r}
p3<- ind2_data %>%
  # filter outliers with too many pops
  filter(n_extant_populations<500) %>%
  
  # plot
    ggplot(aes(x=n_extant_populations, y=indicator2, color=defined_populations_nicenames)) +
    geom_point() +
    theme_light() +
    scale_color_manual(values=simplifiedmethods_colors,
                    breaks=levels(as.factor(ind2_data$defined_populations_nicenames))) +
    theme(legend.position = "none") +
    ylab("Indicator 2") +
    xlab("Number of mantained populations") +
    theme(text = element_text(size = 13))
p3



```

Prepare data
```{r}
# remove missing data 
ind2_data_wo_missing<-ind2_data %>% 
                      filter(!is.na(indicator2)) %>%
                      filter(n_extant_populations<500) # doesn't make a difference in the test below, but useful for plots

# check n per method
table(ind2_data_wo_missing$defined_populations_simplified)

```

Run GLM  model
```{r}
# run model
m2 <- glm(ind2_data_wo_missing$indicator2 ~ ind2_data_wo_missing$n_extant_populations + 
            ind2_data_wo_missing$defined_populations_simplified + 
            ind2_data_wo_missing$n_extant_populations*ind2_data_wo_missing$defined_populations_simplified, family = "quasibinomial")
m2
```

Summary:

```{r}
summary(m2)
```


### Single plot 3 panels for the effect of method to define populations on indicator 2 and number of pops

Plot in three panels
```{r, out.height="380px", out.width="1130px"}
## plot for indicator 2 without axis labels
p2<-ind2_data %>% 
  filter(n_extant_populations<500) %>%
  ggplot(aes(x=defined_populations_simplified, y=indicator2, color=defined_populations_simplified)) +
          geom_boxplot() + xlab("") + ylab("Indicator 2") +
          geom_jitter(size=.4, width = 0.1, color="black") +
  coord_flip() +
  theme_light() +
  theme(panel.border = element_blank(), legend.position="none", axis.text.y = element_blank(),
        plot.margin = unit(c(0, 0, 0, 0), "cm")) + # this is used to decrease the space between plots) + 
  scale_color_manual(values=simplifiedmethods_colors,
                    breaks=levels(as.factor(ind2_data$defined_populations_simplified))) +
  theme(text = element_text(size = 13))
p2

plot_grid(p1, p2, p3, ncol=3, rel_widths = c(2,1,1), align = "h", labels=c("a)", "b)", "c)"))  

```

Option 2:
```{r}
# panel labels
p1<-p1+ggtitle("a)")
p2<-p2+ggtitle("b)")
p3<-p3+ggtitle("c)")

# nested plot!
panel_figure <- plot_grid(
  plot_grid(p1, p2, ncol = 2, rel_widths = c(1.5,1)),  # Arranging p1 and p2 in 2 columns
  p3,                            # Placing p3 centered below p1 and p2
  ncol = 1,                      # Single column layout
  rel_heights = c(2, 1)          # Adjust the relative heights of rows
)

panel_figure

```


## Missing data on extant and extinct populations

We have NA in indicator 2 because in some cases the number of extinct populations is unknown, therefore the operation cannot be computed. 

### Counts
Total records with NA in extant populations:
```{r}
sum(is.na(ind2_data$n_extant_populations))
```

Taxa with NA in extant populations:
```{r}
ind2_data %>%
  filter(is.na(n_extant_populations)) %>%
    select(country_assessment, taxonomic_group, taxon, n_extant_populations, n_extint_populations)
```

Total taxa with NA in **extinct** populations:
```{r}
sum(is.na(ind2_data$n_extint_populations))
```

Do taxa with NA for extant also have NA for extinct?

```{r}
ind2_data$taxon[is.na(ind2_data$n_extant_populations)] %in% ind2_data$taxon[is.na(ind2_data$n_extint_populations)]
```

So out of the `r nrow(ind2_data)`, we have **`r sum(is.na(ind2_data$n_extint_populations))` records with NA in n_extinct** and **`r sum(is.na(ind2_data$n_extant_populations))` records with NA in n_extant**. Of them, `r sum(ind2_data$taxon[is.na(ind2_data$n_extant_populations)] %in% ind2_data$taxon[is.na(ind2_data$n_extint_populations)])` have NA in both n_extant and n_extinct.


### Plot missing data extinct populations
```{r}
ind2_data %>%
  ggplot(aes(x=country_assessment, fill=is.na(n_extint_populations))) +
  geom_bar() +
  scale_fill_manual(labels=c("number of populations known", "missing data"),
                    values=c("#2ca02c", "#ff7f0e")) + 
  labs(fill="Extinct populations") +
  xlab("") + ylab("Number of taxa") +
  theme_light() +
  theme(panel.border = element_blank())
```


### Plot missing data extinct populations by country

Missing data in number of extinct populations by method to define populations:

```{r}
ind2_data %>%
  ggplot(aes(x=defined_populations_nicenames, fill=is.na(n_extint_populations)))+
  geom_bar() +
  coord_flip()+ 
  scale_fill_manual(labels=c("number of populations known", "missing data"),
                    values=c("#2ca02c", "#ff7f0e")) + 
  labs(fill="Extinct populations") +
  xlab("") + ylab("Number of taxa") +
  facet_wrap(country_assessment ~., nrow = 3, scales="free_x") +
  theme_light() +
  theme(panel.border = element_blank(), legend.position="top")
  
```
## Indicator 1 by type of range

Indicator 1 by type of range in the entire dataset:

```{r indicator1 by range type}
# get sample size by desired category
sample_size <- indicator1  %>%
                    filter(!is.na(indicator1)) %>% 
                    group_by(species_range) %>% summarize(num=n())

# plot
indicator1  %>% 
  # add sampling size 
  left_join(sample_size) %>%
  mutate(myaxis = paste0(species_range, " (n= ", num, ")")) %>%

  # plot
  ggplot(aes(x=myaxis, y=indicator1 , fill=species_range)) +
      geom_violin(width=1, linewidth = 0)  +
      geom_jitter(size=.5, width = 0.1) +
      xlab("") + ylab("Proportion of popuations with Ne > 500") +
      coord_flip() +
      scale_fill_manual(breaks=c("wide_ranging", "restricted", "unknown"),
                       labels=c("wide ranging", "restricted", "unknown"),
                       values=c("#F8766D", "#00BFC4", "grey80")) +
      theme_light() +
      theme(panel.border = element_blank(), legend.position="none", text= element_text(size=20))
```
Indicator 1 by country and type of range

```{r indicator1 by country and range}
### Duplicate dataframe to have a column with "all data" for faceting
df<-CreateAllFacet(indicator1 , "country_assessment")

# order with "all" as last
df$facet <- factor(df$facet, levels=c("Australia", "Belgium", "Colombia", "France", "Japan", "Mexico", "S. Africa", "Sweden", "US", "all"))

## plot
df  %>% 
  # filter out "unknown" range
  filter(species_range!="unknown") %>%
  
# plot
ggplot(aes(x=species_range, y=indicator1 , fill=species_range)) +
      geom_violin(width=1, linewidth = 0)  +
      geom_jitter(size=.5, width = 0.1) +
      xlab("") + ylab("Proportion of popuations with Ne > 500") +
      coord_flip() +
      scale_x_discrete(breaks=c("wide_ranging", "restricted"),
                        labels=c("wide ranging", "restricted")) +
      theme_light() +
      theme(panel.border = element_blank(), legend.position="none", text= element_text(size=15)) +
      facet_wrap(~facet, ncol = 5) +
      theme(panel.spacing = unit(1.5, "lines"))  
  
```
Test the effect of range on indicator1 with country as a random effect.

```{r stats indicator1 and range}
library(lme4)
## Remove unknown
data<-indicator1 %>%
     filter(species_range!="unknown")
  
## run model with glm
m1 <- glm(data$indicator1 ~ data$species_range + data$country_assessment, family = "quasibinomial")
summary(m1)

# or with lme4?
m2 <-lmer(indicator1 ~ species_range + (1|country_assessment), data = data)
summary(m2)

```


## Indicator 1 by IUCN status

Indicator 1 by global IUCN in the entire dataset:

```{r indicator1 gobalIUCN}

## Global IUCN
## prepare data
# add sampling size
sample_size <- indicator1 %>%
               filter(!is.na(indicator1)) %>% 
               group_by(global_IUCN) %>% summarize(num=n())

# new df 
df<- indicator1 %>% 
     filter(!is.na(indicator1)) %>% 
        # add sampling size 
        left_join(sample_size) %>%
        mutate(myaxis = paste0(global_IUCN, " (n= ", num, ")"))


# change order of levels so that they are in the desired order
df$myaxis<-factor(df$myaxis, 
                  #grep is used below to get the sample size, which may change depending on the data
                  levels=c(grep("cr", unique(df$myaxis), value = TRUE),
                          grep("en", unique(df$myaxis), value = TRUE),
                          grep("vu", unique(df$myaxis), value = TRUE),
                          grep("nt", unique(df$myaxis), value = TRUE),
                          grep("lc", unique(df$myaxis), value = TRUE),
                          grep("dd", unique(df$myaxis), value = TRUE),
                          grep("not_assessed", unique(df$myaxis), value = TRUE),
                          grep("unknown", unique(df$myaxis), value = TRUE)))

df$global_IUCN<-factor(df$global_IUCN, levels=c("cr", "en", "vu", "nt", "lc", "dd", "not_assessed", "unknown"))


      
# plot
p1<-df %>%
    ggplot(aes(x=myaxis, y=indicator1 , fill=global_IUCN)) +
      geom_violin(width=1, linewidth = 0)  +
      geom_jitter(size=.5, width = 0.1) +
      xlab("") + ylab("Proportion of popuations with Ne > 500") +
      coord_flip() +
      scale_fill_manual(values= IUCNcolors, # iucn color codes
                        breaks=c(levels(df$global_IUCN))) +
      theme_light() +
      ggtitle("a) global Red List") +
      theme(panel.border = element_blank(), legend.position="none", text= element_text(size=15))
p1

```


Indicator 1 by IUCN in the entire dataset:

```{r indicator1 regionalIUCN}
## Regional IUCN

## prepare data
# add sampling size
sample_size <- indicator1 %>%
               filter(!is.na(indicator1)) %>% 
               group_by(regional_redlist) %>% summarize(num=n())

# new df 
df<- indicator1 %>% 
     filter(!is.na(indicator1)) %>% 
        # add sampling size 
        left_join(sample_size) %>%
        mutate(myaxis = paste0(regional_redlist, " (n= ", num, ")"))

# change order of levels so that they are in the desired order
df$myaxis<-factor(df$myaxis, 
                  #grep is used below to get the sample size, which may change depending on the data
                  levels=c(grep("re", unique(df$myaxis), value = TRUE),
                          grep("cr", unique(df$myaxis), value = TRUE),
                          grep("en", unique(df$myaxis), value = TRUE),
                          grep("vu", unique(df$myaxis), value = TRUE),
                          grep("nt", unique(df$myaxis), value = TRUE),
                          grep("lc", unique(df$myaxis), value = TRUE),
                          grep("dd", unique(df$myaxis), value = TRUE),
                          grep("not_assessed", unique(df$myaxis), value = TRUE),
                          grep("unknown", unique(df$myaxis), value = TRUE)))

df$regional_redlist<-factor(df$regional_redlist, levels=c("re","cr", "en", "vu", "nt", "lc", "dd", "not_assessed", "unknown"))
      
# plot
p2<-df %>%
    ggplot(aes(x=myaxis, y=indicator1 , fill=regional_redlist)) +
      geom_violin(width=1, linewidth = 0)  +
      geom_jitter(size=.5, width = 0.1) +
      xlab("") + ylab("Proportion of popuations with Ne > 500") +
      coord_flip() +
      scale_fill_manual(values= IUCNcolors_regional, # iucn color codes
                        breaks=c(levels(df$regional_redlist))) +
      theme_light() +
      ggtitle("b) regional Red List") +
      theme(panel.border = element_blank(), legend.position="none", text= element_text(size=15))
p2


```

Both together

```{r indicator1 IUCN global regional}
plot_grid(p1, p2, ncol=2)
```
Indicator 1 by country and global IUCN

```{r indicator1 country globalIUCN}
## change order of levels so that categories match with the order of colors
indicator1$global_IUCN<-factor(indicator1$global_IUCN, levels=c("cr", "en", "vu", "nt", "lc", "dd", "not_assessed", "unknown"))

# plot
indicator1 %>% 
  # plot
  ggplot(aes(x=global_IUCN, y=indicator1, fill=global_IUCN)) +
      geom_violin(width=1, linewidth = 0)  +
      geom_jitter(size=.5, width = 0.1) +
      xlab("") + ylab("Proportion of popuations with Ne > 500") +
      coord_flip() +
      scale_fill_manual(values= IUCNcolors, # iucn color codes
                    breaks=c(levels(indicator1$global_IUCN))) +
      theme_light() +
      ggtitle("global IUCN Redlist") +
      theme(panel.border = element_blank(), legend.position="none", text= element_text(size=13)) +
      facet_wrap(~country_assessment, ncol = 3) +
      theme(panel.spacing = unit(1.5, "lines"))
```

Indicator1 by regional IUCN Redlist, excluding US and Mexico becasue they don't have a regional IUCN redlist.

```{r indicator1 country regionalIUCN}
## change order of levels so that categories match with the order of colors
indicator1$regional_redlist<-factor(indicator1$regional_redlist, levels=c("re","cr", "en", "vu", "nt", "lc", "dd", "not_assessed", "unknown"))

# plot
indicator1 %>% 
  # filter US and Mx
  filter(country_assessment!="Mexico", country_assessment!="US") %>%
  
  # plot
  ggplot(aes(x=regional_redlist, y=indicator1, fill=regional_redlist)) +
      geom_violin(width=1, linewidth = 0)  +
      geom_jitter(size=.5, width = 0.1) +
      xlab("") + ylab("Proportion of popuations with Ne > 500") +
      coord_flip() +
      scale_fill_manual(values= IUCNcolors_regional, # iucn color codes
                    breaks=c(levels(indicator1$regional_redlist))) +
      theme_light() +
      ggtitle("regional IUCN Redlist") +
      theme(panel.border = element_blank(), legend.position="none", text= element_text(size=15)) +
      facet_wrap(~country_assessment, ncol = 4) +
      theme(panel.spacing = unit(1.5, "lines"))
```

## Values of indicator 1 and indicator 2 for multiassessed species

```{r}
#subset only with taxa assessed multiple times:
only_multi<-indicators_full %>% 
                          filter(multiassessment=="multiassessment") 
```

First, check how indicator 1 changes across the multiassessments.

```{r}
only_multi %>% 
  # Keep rows with different values in indicator1 within each taxon group
  group_by(taxon) %>%
  filter(n_distinct(indicator1) > 1) %>%
  # plot
  ggplot(aes(x=taxon, y=indicator1)) +
          geom_line(colour="darkgrey") + 
          geom_point(aes(color=country_assessment)) +
  xlab("") + ylab("Proportion of popuations with Ne > 500") +
  labs(color="country") +
  ylim(0, 1)+
  coord_flip() +
  theme_light() + 
  theme(panel.border = element_blank(), legend.position="right", text= element_text(size=13))

```

Now check how indicator 2 changes across the multiassessments.
To be able to visualize the missing data, the following plot changes NA to -1.
```{r}
only_multi %>% 
  # Keep rows with different values in indicator1 within each taxon group
  group_by(taxon) %>%
  filter(n_distinct(indicator2) > 1) %>%
  
  ggplot(aes(x=taxon, y=indicator2)) +
          geom_line(colour="darkgrey") + 
          geom_point(aes(color=country_assessment)) +
  xlab("") + ylab("Proportion of populations mantained ") +
  labs(color="country") +
  coord_flip() +
  theme_light() + 
  theme(panel.border = element_blank(), legend.position="right", text= element_text(size=13))
```
## Indicator 3 (number of species with genetic diversity monitoring)
Indicator 3 refers to the number (count) of taxa by country in which genetic monitoring is occurring. This is stored in the variable temp_gen_monitoring as a “yes/no” answer for each taxon.

```{r}
indicator3
```

Plot by global IUCN redlist status
```{r}
# desired order of levels
indicators_full$global_IUCN<-factor(as.factor(indicators_full$global_IUCN), levels=c("cr", "en", "vu", "nt", "lc", "dd", "not_assessed", "unknown"))


## plot
indicators_full %>%
                 # keep only one record if the taxon was assessed more than once within the country
                 select(country_assessment, taxon, temp_gen_monitoring, global_IUCN) %>%
                 filter(!duplicated(.)) %>%

                 # count "yes" in tem_gen_monitoring by country
                 filter(temp_gen_monitoring=="yes") %>%
ggplot(aes(x=country_assessment, fill=global_IUCN)) +
  geom_bar() +
  xlab("") + ylab("Number of taxa with temporal genetic diversity monitoring") +
  scale_fill_manual(values= IUCNcolors, # iucn color codes
                    breaks=levels(as.factor(indicators_full$global_IUCN))) +
      theme_light()
```

Relatively few taxa have genetic monitoring, but many have some sort of genetic study. Let’s check that with a Sankey Plot:

```{r}
# first subset the ind3_data keeping only taxa assessed a single time, plust the first record of those assessed multiple times.
ind3_data_firstmulti<-ind3_data[!duplicated(cbind(ind3_data$taxon, ind3_data$country_assessment)), ]

# transform data to how ggsankey wants it
df <- ind3_data_firstmulti %>%
  make_long(country_assessment, temp_gen_monitoring, gen_studies)

# plot
ggplot(df, aes(x = x,
               next_x = next_x,
               node = node,
               next_node = next_node,
               fill = factor(node),
               label = node)) +
  geom_sankey(flow.alpha = 0.5, 
              show.legend = FALSE) +
  geom_sankey_label(size = 2.5, color = "black", fill = "white") +
  theme_sankey(base_size = 10) +

    # manually set flow fill according to desired color
                            # countries
  scale_fill_manual(values=c(scales::hue_pal()(length(unique(ind3_data_firstmulti$country_assessment))),  
                             # traffic light for monitoring
                             c("darkolivegreen", "brown3", "darkgrey"),
                             # nice soft colors for gen_studies
                             c("grey50", "grey35", "grey50", "brown3")),
                              
                    breaks=c(unique(ind3_data_firstmulti$country_assessment),
                             unique(ind3_data_firstmulti$temp_gen_monitoring),
                             unique(ind3_data_firstmulti$gen_studies))) +
  
  xlab("")
```

```{r}
table(ind3_data_firstmulti$gen_studies)
```


Count data:
```{r}
ind3_data %>%
                 # keep only one record if the taxon was assessed more than once within the country
                 select(country_assessment, taxon, gen_studies, temp_gen_monitoring) %>%
                 filter(!duplicated(.)) %>%

                 group_by(country_assessment, temp_gen_monitoring, gen_studies) %>%
                 summarise(n_studies=n())
```

How many genetic studies ara available by country for species without temporal genetic diversity monitoring?
```{r}
## plot
indicators_full %>%
                 # keep only one record if the taxon was assessed more than once within the country
                 select(country_assessment, taxon, temp_gen_monitoring, gen_studies) %>%
                 filter(!duplicated(.)) %>%
                 # keep only taxa without gen div monitoring
                 filter(temp_gen_monitoring=="no")%>%

ggplot(aes(x=country_assessment, fill=gen_studies)) +
  geom_bar() +
    scale_fill_manual(values=c("grey80", scales::hue_pal()(3)))+
  xlab("")  +
      theme_light()
```




---
title: "Main figures and analyses for the manuscript"
output:
  html_document:
    df_print: paged
    toc: true
date: "2023-08-03"
---

This notebook estimates the indicators based on the raw data and perfomrs the main analyses and figures used in the manuscript of the multicountry paper. The input is the "clean kobo output" that was first cleaned by `1.2_cleaning`.

## Packages and functions

Load required libraries:

```{r, warning=FALSE, message=FALSE}
library(tidyr)
library(dplyr)
library(utile.tools)
library(stringr)
library(ggplot2)
library(ggsankey)
library(alluvial)
library(viridis)
library(cowplot)
```

Load required functions. These custom fuctions are available at: https://github.com/AliciaMstt/GeneticIndicators

```{r}
source("get_indicator1_data.R")
source("get_indicator2_data.R")
source("get_indicator3_data.R")
source("get_metadata.R")
source("transform_to_Ne.R")
source("estimate_indicator1.R")
```

Other custom functions:
```{r}
### not in
'%!in%' <- function(x,y)!('%in%'(x,y))


#' Duplicates data to create additional facet. Thanks to https://stackoverflow.com/questions/18933575/easily-add-an-all-facet-to-facet-wrap-in-ggplot2
#' @param df a dataframe
#' @param col the name of facet column
#'  
CreateAllFacet <- function(df, col){
  df$facet <- df[[col]]
  temp <- df
  temp$facet <- "all"
  merged <-rbind(temp, df)

  # ensure the facet value is a factor
  merged[[col]] <- as.factor(merged[[col]])

  return(merged)
}
```

Custom colors:
```{r}
## IUCN official colors
IUCNcolors<-c("brown2", "darkgrey", "darkorange", "darkgreen", "bisque1", "green", "azure2", "yellow")

## nice soft ramp for taxonomic groups
taxoncolors<-cividis(12) # same than using cividis(length(levels(as.factor(metadata$taxonomic_group))))

## Colors for simplified methods to define populations 
# assuming the following  levels (see how this was created in the section "Simplify combinations of methods to define populations"): levels(as.factor(ind2_data$defined_populations_simplified))
# [1] "adaptive_traits management_units"         "eco_biogeo_proxies"                       "genetic_clusters"                        
# [4] "genetic_clusters eco_biogeo_proxies"      "genetic_clusters geographic_boundaries"   "geographic_boundaries"                   
# [7] "geographic_boundaries adaptive_traits"    "geographic_boundaries eco_biogeo_proxies" "geographic_boundaries management_units"  
# [10] "low_freq_combinations"                    "management_units"                         "other"  
# get a set of colors to highlight genetic and geographic with similar colors

simplifiedmethods_colors<-c("#b34656", #"adaptive_traits management_units"
                            "#7f611b", # "eco_biogeo_proxies"
                            "#668cd1", # "genetic_clusters"     
                            "#668cd1", # "genetic_clusters eco_biogeo_proxies"     
                            "#45c097", # "genetic_clusters geographic_boundaries"  
                            "#d4b43e", # "geographic_boundaries"                   
                            "#d4b43e", # "geographic_boundaries adaptive_traits"
                            "#d4b43e", # "geographic_boundaries eco_biogeo_proxies"
                            "#d4b43e", # "geographic_boundaries management_units"  
                            "#be72c9", # "low_freq_combinations" 
                            "#b93921", # "management_units" 
                            "#d868a2")# "other" 
  
```

## Get data and estimate indicators
Get indicators and metadata data from clean kobo output
```{r, echo=TRUE}
# Get data:
kobo_clean<-read.csv(file="kobo_output_clean.csv", header=TRUE)

# Extract indicator 2 data from kobo output, show most relevant columns
ind2_data<-get_indicator2_data(kobo_output=kobo_clean)
head(ind2_data[,c(1:3, 9:10,13)])

# Extract indicator 3 data from kobo output, show most relevant columns
ind3_data<-get_indicator3_data(kobo_output=kobo_clean)
head(ind3_data[,c(1:3, 9:11)])

# extract metadata, show most relevant columns
metadata<-get_metadata(kobo_output=kobo_clean)
head(metadata[,c(1:3, 12, 25,26, 64)])
```


### Indicator 1 (proportion of populations with Ne >500):

Extract indicator 1 data from kobo output, show most relevant columns
```{r}
ind1_data<-get_indicator1_data(kobo_output=kobo_clean)
head(ind1_data[,c(1:3, 12:14)])

```

Remember what the function to transform NcRange and NcPoint data into Ne does:
```{r}
# check what the custom funciton does
transform_to_Ne
```

Use function to get Ne data from NcRange or NcPoint data, and their combination (Ne estimated from Ne if Ne is available, otherwise, from Nc)

```{r}
ind1_data<-transform_to_Ne(ind1_data = ind1_data)
```

Remember what the function to estimate indicator 1 does:
```{r}
# check what the custom function does
estimate_indicator1
```

**Now estimate indicator 1 :)**

```{r}
indicator1<-estimate_indicator1(ind1_data = ind1_data)
```

### Indicator 2 (proportion of populations within species which are maintained)

Indicator 2 is the he proportion of populations within species which are maintained. This can be estimated based on the `n_extant_populations` and `n_extint_populations`, as follows:

```{r}
ind2_data$indicator2<- ind2_data$n_extant_populations / (ind2_data$n_extant_populations + ind2_data$n_extint_populations)
head(ind2_data$indicator2)
```

### Indicator 3 (number of taxa with genetic monitoring squemes)

Indicator 3 refers to the number (count) of taxa by country in which genetic monitoring is occurring. This is stored in the variable `temp_gen_monitoring` as a "yes/no" answer for each taxon, so to estimate the indicator, we only need to count how many said "yes", keeping only one of the records when the taxon was multiassessed:

```{r}
indicator3<-ind3_data %>%
                 # keep only one record if the taxon was assessed more than once within the country
                 select(country_assessment, taxon, temp_gen_monitoring) %>%
                 filter(!duplicated(.)) %>%

                 # count "yes" in tem_gen_monitoring by country
                 filter(temp_gen_monitoring=="yes") %>%
                 group_by(country_assessment) %>%
                 summarise(n_taxon_gen_monitoring= n())
```

### Join indicators and metadata in a single table

It could be useful to have the estimated indicator and the metadata in a single large table.
```{r}
indicators_full<-left_join(metadata, indicator1) %>% 
                     left_join(ind2_data) %>% 
                     left_join(ind3_data)
```

### Save indicators data
Save indicators data and metadata to csv files, useful for analyses outside R.

```{r}
# save processed data
write.csv(ind1_data, "ind1_data.csv", row.names = FALSE, fileEncoding = "UTF-8")
write.csv(indicators_full, "indicators_full.csv", row.names = FALSE, fileEncoding = "UTF-8")
write.csv(ind2_data, "ind2_data.csv", row.names = FALSE, fileEncoding = "UTF-8")
write.csv(ind3_data, "ind3_data.csv", row.names = FALSE, fileEncoding = "UTF-8")
write.csv(metadata, "metadata.csv", row.names = FALSE, fileEncoding = "UTF-8")

```


## Change country name to nicer labels

To have nice levels in the plots we will change the way country names are written: 

```{r}
# make factor
metadata$country_assessment<-as.factor(metadata$country_assessment)
ind1_data$country_assessment<-as.factor(ind1_data$country_assessment)

# original levels
levels(metadata$country_assessment)

# change
levels(metadata$country_assessment)<-c("Australia", "Belgium", "Colombia", "France", "Japan", "Mexico", "S. Africa", "Sweden", "US")
levels(ind1_data$country_assessment)<-c("Australia", "Belgium", "Colombia", "France", "Japan", "Mexico", "S. Africa", "Sweden", "US")

```


## Simplify combinations of methods to define populations

The methods used to define populations come from a check box question were one or more of the following categories can be selected: genetic_clusters, geographic_boundaries, eco_biogeo_proxies, adaptive_traits, management_units, other. As a consequence any combination of the former can be possible. Leading to the following frequency table:

```{r}
table(ind2_data$defined_populations)
```

It is hard to group the above methods, so we will keep the original groups with n >=19 in the above list, and tag the combinations that appear few times as as "low_freq_combinations".

Which groups have n>=19?
```{r}
x<-as.data.frame(table(ind2_data$defined_populations)[table(ind2_data$defined_populations) >= 19])
colnames(x)[1]<-"method"

x

```
We can add this new column to the metadata and indicator 2 data:

```{r} 
### for ind2_data
ind2_data<- ind2_data %>% 
  mutate(defined_populations_simplified = case_when(
         # if the method is in the list of methods n>=19 then keep it
         defined_populations %in% x$method ~ defined_populations,
         TRUE ~ "low_freq_combinations"))


### for meta
metadata<- metadata %>% 
  mutate(defined_populations_simplified = case_when(
         # if the method is in the list of methods n>=19 then keep it
         defined_populations %in% x$method ~ defined_populations,
         TRUE ~ "low_freq_combinations"))
         
```


Check n for simplified methods:

```{r}
table(ind2_data$defined_populations_simplified)
```

Table of equivalences:

```{r}
ind2_data %>% 
       select(defined_populations, defined_populations_simplified) %>% 
       filter(!duplicated(defined_populations))
```

## Number or records and taxa assessed by country

Records by country, including taxa assessed more than once (see below for details on this)

```{r, out.width="700px", out.height="400px"}
ggplot(metadata, aes(x=country_assessment)) + 
  geom_bar(stat = "count") +
  xlab("") +
  ggtitle("Number of taxa assessed by country, including taxa assed more than once")

```
Some taxa were assessed twice, for example to account for uncertainty on how to divide populations. This information is stored in variable `multiassessment` of the metadata (created by `get_metadata()`). An example of taxa with multiple assessments:

```{r}
metadata %>%
filter(multiassessment=="multiassessment")  %>%
  select(taxonomic_group, taxon, country_assessment, multiassessment) %>%
  arrange(taxon, country_assessment) %>%
  head()
  
```

To explore what kind of taxa countries assessed regardless of if they assessed them once or more, lets create a dataset keeping all single assessed taxa, plus only the first assessment for taxa assessed multiple times. 

```{r}
# object with single assessed taxa, plus only the first assessment for taxa assessed multiple times
metadata_firstmulti<-metadata[!duplicated(cbind(metadata$taxon, metadata$country_assessment)), ]

```

How many taxa were assessed (i.e. counting only once taxa that were assessed multiple times)?
```{r}
# how many?
nrow(metadata_firstmulti)
```

Plot taxa assessed excluding duplicates, i.e. the real number of taxa assessed:

```{r, out.width="700px", out.height="400px"}
ggplot(metadata_firstmulti, aes(x=country_assessment)) + 
  geom_bar(stat = "count") +
  xlab("") +
  ggtitle("Number of taxa assessed by country")

```

Of which countries and taxonomic groups are the taxa that were assessed more than once?
```{r}
metadata_firstmulti %>% # we use the _unique dataset so that multiassesed records are counted only once
        filter(multiassessment=="multiassessment") %>%

ggplot(aes(x=taxonomic_group, fill=country_assessment)) + 
  geom_bar(stat = "count") +
  theme(axis.text.x = element_text(angle = 45)) +
  labs(fill="Country") +
  ggtitle("Number of taxa assessed more than once")


```

## Population size data (Has Nc or Ne? what type of Nc?)

Countries have population size data (Nc or Ne) regardless of the taxonomic group.

```{r}
ggplot(metadata, aes(x=taxonomic_group, fill=popsize_data)) + 
  geom_bar(stat = "count") +
  coord_flip() +
  facet_wrap(~country_assessment, ncol = 5) +
  scale_fill_manual(values=c("#1f77b4", "grey80", "#2ca02c"),
                    breaks=c(levels(as.factor(metadata$popsize_data))),
                    labels=c("Species level or subspecies level", "Insufficient data", "Population level")) +
  labs(fill="Population size data availability",
       x="",
       y="Number of taxa (including records of taxa assessed more than once)") +
  theme_light() +
  theme(legend.position="bottom")
  
```

Same plot but including a panel for the entire dataset:

```{r}
## Duplicate data with an additional column "facet"

df<-CreateAllFacet(metadata, "country_assessment")

# order with "all" as last
df$facet <- factor(df$facet, levels=c("Australia", "Belgium", "Colombia", "France", "Japan", "Mexico", "S. Africa", "Sweden", "US", "all"))

# Plot
ggplot(df, aes(x=taxonomic_group, fill=popsize_data)) + 
  geom_bar(stat = "count") +
  coord_flip() +
  facet_wrap(~facet, ncol = 5, scales="free_x") +
  scale_fill_manual(values=c("#1f77b4", "grey80", "#2ca02c"),
                    breaks=c(levels(as.factor(metadata$popsize_data))),
                                        labels=c("Species level or subspecies level", "Insufficient data", "Population level")) +
  labs(fill="Population size data availability",
       x="",
       y="Number of taxa (including records of taxa assessed more than once)") +
  theme_light() +
  theme(legend.position="bottom")

```

Option 2:
```{r}
## Duplicate data with an additional column "facet"

df<-CreateAllFacet(metadata, "country_assessment")

# order with "all" as last
df$facet <- factor(df$facet, levels=c("Australia", "Belgium", "Colombia", "France", "Japan", "Mexico", "S. Africa", "Sweden", "US", "all"))

# Plot
ggplot(df, aes(x=taxonomic_group, fill=popsize_data)) + 
  geom_bar(stat = "count") +
  coord_flip() +
  facet_wrap(~facet, ncol = 5) +
  scale_fill_manual(values=c("#1f77b4", "grey80", "#2ca02c"),
                    breaks=c(levels(as.factor(metadata$popsize_data))),
                    labels=c("Species level or subspecies level", "Insufficient data", "Population level")) +
  labs(fill="Population size data availability",
       x="",
       y="Number of taxa (including records of taxa assessed more than once)") +
  theme_light() +
  theme(legend.position="bottom")

```
Population size data availability in the entire dataset:
```{r}
ggplot(metadata, aes(x=taxonomic_group, fill=popsize_data)) + 
  geom_bar(stat = "count") +
  coord_flip() +
  scale_fill_manual(values=c("#1f77b4", "grey80", "#2ca02c"),
                    breaks=c(levels(as.factor(metadata$popsize_data))),
                                        labels=c("Species level or subspecies level", "Insufficient data", "Population level")) +
  labs(fill="Population size data availability",
       x="",
       y="Number of taxa (including records of taxa assessed more than once)") +
  theme_light() +
  theme(legend.position="right")
```


### Ne data yes or not?

```{r}
p1<- metadata %>% 
  filter(!is.na(ne_pops_exists)) %>% 
  filter(ne_pops_exists!="other_genetic_info") %>%
    ggplot(aes(x=country_assessment, fill=ne_pops_exists)) + 
  geom_bar() +
scale_fill_manual(labels=c("no", "yes"),
                      breaks=c("no_genetic_data", "ne_available"),
                      values=c("#ff7f0e", "#2ca02c")) +
  coord_flip()  +
xlab("") +
ylab("Number of taxa") +
labs(fill="")  +
theme_bw() +
theme(text = element_text(size = 14), legend.position = "top", panel.border = element_blank(),
      #center legend
      plot.title = element_text(hjust = 0.5, size=14)) +
ggtitle("a) Ne available \n(from genetic data)")

p1

```

Nc data available by taxa?
```{r}
p2<-metadata %>%
  filter(!is.na(nc_pops_exists)) %>%
  ggplot(aes(x=country_assessment, fill=nc_pops_exists))+
  geom_bar() +
  coord_flip() + 
  scale_fill_manual(values=c("#ff7f0e", "#2ca02c")) + 
  labs(fill="") +
  xlab("") +
  ylab("Number of taxa") +
  theme_bw() +
  theme(text = element_text(size = 14), legend.position = "top", panel.border = element_blank(),
      #center legend
      plot.title = element_text(hjust = 0.5, size=14)) +
  ggtitle("b) Nc available")
p2
```

What kind of Nc data?
```{r}
p3<-ind1_data %>%
  filter(!is.na(NcType)) %>%
  ggplot(aes(x=country_assessment, fill=NcType))+
  geom_bar(position = "dodge") +
  coord_flip() + 
  scale_fill_discrete(labels=c("Point", "Range \nor qualitative", "Unknown"),
                     breaks=c("Nc_point", "Nc_range", "unknown")) +
  xlab("") +
  ylab("Number of populations") +
  ggtitle("c) Type of Nc data by population") +
  theme_bw() +
  theme(text = element_text(size = 14), legend.position = "top", panel.border = element_blank(),
      #center legend
      plot.title = element_text(hjust = 0.5, size=14)) +
  labs(fill="")
p3
 
```

Distribution of Nc, Ne and types of Ne in a single figure with 3 panels:


```{r, out.width="1000px", out.height="350px"}
p2<- p2 + theme(axis.text.y=element_blank())
p3<- p3 + theme(axis.text.y=element_blank())

# plot
plot_grid(p1, p2, p3, ncol=3, rel_widths = c(1.2,1,1), align = "h")  
```

## Effect of method used to define populations on number of populations and indicator 2

### Plot
Prepare data for nice labels:

```{r}
# original method names
levels(as.factor(ind2_data$defined_populations_simplified))

# nice methods names
nice_names <- c("adaptive traits & management units",
                "eco- biogeographic proxies",
               "genetic clusters",
               "genetic clusters & eco- biogeographic proxies",
               "genetic clusters & geographic boundaries",
               "geographic boundaries",
               "geographic boundaries & adaptive traits",
               "geographic boundaries & eco- biogeographic proxies",
               "geographic boundaries & management units",
               "low frequency combinations",
               "management units",
               "others")
## add them
ind2_data$defined_populations_nicenames<-as.factor(ind2_data$defined_populations_simplified)
levels(ind2_data$defined_populations_nicenames)<-nice_names
  
# sample size of TOTAL populations
sample_size <- ind2_data %>%
                    filter(!is.na(indicator2)) %>% 
                    group_by(defined_populations_nicenames) %>% summarize(num=n())

# custom axis
## new dataframe
df<-ind2_data %>% 
  filter(n_extant_populations<500) %>%
    # add sampling size 
  left_join(sample_size) %>%
  mutate(myaxis = paste0(defined_populations_nicenames, " (n= ", num, ")"))


```

Plot number of populations and indicator 2 by method
```{r, out.height="500px", out.width="1064px"}
# plot for number of pops
  p1<- df %>%
  ggplot(aes(x=myaxis, y=n_extant_populations, color=defined_populations_simplified)) +
          geom_boxplot() + xlab("") + ylab("Number of mantained populations") +
          geom_jitter(size=.4, width = 0.1, color="black") +
  coord_flip() +
  theme_bw() +
  theme(panel.border = element_blank(), legend.position="none",
        plot.margin = unit(c(0, 0, 0, 0), "cm")) + # this is used to decrease the space between plots
  scale_color_manual(values=simplifiedmethods_colors,
                    breaks=levels(as.factor(ind2_data$defined_populations_simplified))) +
  theme(text = element_text(size = 13))

## plot for indicator 2
p2<-ind2_data %>% 
  filter(n_extant_populations<500) %>%
  ggplot(aes(x=defined_populations_simplified, y=indicator2, color=defined_populations_simplified)) +
          geom_boxplot() + xlab("") + ylab("Indicator 2") +
          geom_jitter(size=.4, width = 0.1, color="black") +
  coord_flip() +
  theme_bw() +
  theme(panel.border = element_blank(), legend.position="none", axis.text.y = element_blank(),
        plot.margin = unit(c(0, 0, 0, 0), "cm")) + # this is used to decrease the space between plots) + 
  scale_color_manual(values=simplifiedmethods_colors,
                    breaks=levels(as.factor(ind2_data$defined_populations_simplified))) +
  theme(text = element_text(size = 13))

plot_grid(p1, p2, ncol=2, rel_widths = c(1.5,1))
```
Scatter plot of indicator2 and extant pops
```{r}
p3<- ind2_data %>%
  # filter outliers with too many pops
  filter(n_extant_populations<500) %>%
  
  # plot
    ggplot(aes(x=n_extant_populations, y=indicator2, color=defined_populations_simplified)) +
    geom_point() +
    theme_bw() +
    scale_color_manual(values=simplifiedmethods_colors,
                    breaks=levels(as.factor(ind2_data$defined_populations_simplified))) +
    theme(legend.position = "none") +
    ylab("Indicator 2") +
    xlab("Number of mantained populations") +
    theme(text = element_text(size = 13))
p3



```
Plot in three panels
```{r, out.height="380px", out.width="1130px"}
plot_grid(p1, p2, p3, ncol=3, rel_widths = c(2,1,1), align = "h", labels=c("a)", "b)", "c)"))  

```

Option 2:
```{r}
# panel labels
p1<-p1+ggtitle("a)")
p2<-p2+ggtitle("b)")
p3<-p3+ggtitle("c)")

# nested plot!
panel_figure <- plot_grid(
  plot_grid(p1, p2, ncol = 2, rel_widths = c(1.5,1)),  # Arranging p1 and p2 in 2 columns
  p3,                            # Placing p3 centered below p1 and p2
  ncol = 1,                      # Single column layout
  rel_heights = c(2, 1)          # Adjust the relative heights of rows
)

panel_figure

```



### Stat analyses for panel 3 (number of pops vs indicator)

Prepare data
```{r}
# remove missing data 
ind2_data_wo_missing<-ind2_data %>% 
                      filter(!is.na(indicator2)) %>%
                      filter(n_extant_populations<500) # doesn't make a difference in the test below, but useful for plots

# check n per method
table(ind2_data_wo_missing$defined_populations_simplified)

```

Run model
```{r}
# run model
m2 <- glm(ind2_data_wo_missing$indicator2 ~ ind2_data_wo_missing$n_extant_populations + 
            ind2_data_wo_missing$defined_populations_simplified + 
            ind2_data_wo_missing$n_extant_populations*ind2_data_wo_missing$defined_populations_simplified, family = "quasibinomial")
m2
```

Summary:

```{r}
summary(m2)
```



## Missing data on extinct populations

## Indicator 1 by type of range

## Indicator 1 by IUCN status

## Values of indicator 1 and indicator 2 for multiassessed species
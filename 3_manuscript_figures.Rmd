---
title: "Main figures and analyses for the manuscript"
output:
  html_document:
    df_print: paged
    toc: true
---

This notebook estimates the indicators based on the raw data and perfomrs the main analyses and figures used in the manuscript of the multicountry paper. The input is the "clean kobo output" that was first cleaned by `1.2_cleaning`.

## Packages and functions

Load required libraries:

```{r, warning=FALSE, message=FALSE}
library(tidyr)
library(dplyr)
library(readr)
library(utile.tools)
library(stringr)
library(ggplot2)
library(ggsankey)
library(alluvial)
library(viridis)
library(cowplot)
library(lme4)
library(knitr)
library(glmmTMB)
```

Load required functions. These custom fuctions are available at: https://github.com/AliciaMstt/GeneticIndicators

```{r source}
source("get_indicator1_data.R")
source("get_indicator2_data.R")
source("get_indicator3_data.R")
source("get_metadata.R")
source("transform_to_Ne.R")
source("estimate_indicator1.R")
```

Other custom functions:
```{r custom_funs}
### not in
'%!in%' <- function(x,y)!('%in%'(x,y))


#' Duplicates data to create additional facet. Thanks to https://stackoverflow.com/questions/18933575/easily-add-an-all-facet-to-facet-wrap-in-ggplot2
#' @param df a dataframe
#' @param col the name of facet column
#'  
CreateAllFacet <- function(df, col){
  df$facet <- df[[col]]
  temp <- df
  temp$facet <- "all"
  merged <-rbind(temp, df)

  # ensure the facet value is a factor
  merged[[col]] <- as.factor(merged[[col]])

  return(merged)
}
```

Custom colors:
```{r custom colors}
## IUCN official colors
# Assuming order of levels is: "re", "cr", "en", "vu", "nt", "lc", "dd", "not_assessed", "unknown" (for regional, and w/o "re" for global). Make sure to change the levels to that order before plotting.
IUCNcolors<-c("brown2", "darkorange", "yellow", "green", "darkgreen", "darkgrey", "azure2", "bisque1")
IUCNcolors_regional<-c("darkorchid2", "brown2", "darkorange", "yellow", "green", "darkgreen", "darkgrey", "azure2", "bisque1")

## nice soft ramp for taxonomic groups
taxoncolors<-cividis(12) # same than using cividis(length(levels(as.factor(metadata$taxonomic_group))))

## Colors for simplified methods to define populations 
# assuming the levels (see how this was created in the section "Simplify combinations of methods to define populations"): of running levels(as.factor(ind2_data$defined_populations_simplified)) (after new order)

# get a set of colors to highlight genetic and geographic with similar colors

simplifiedmethods_colors<-c("#FFA07A", #"dispersal_buffer"
                            "#7f611b", # "eco_biogeo_proxies"
                            "#668cd1", # "genetic_clusters"     
                            "#668cd1", # "genetic_clusters eco_biogeo_proxies"     
                            "#45c097", # "genetic_clusters geographic_boundaries"  
                            "#d4b43e", # "geographic_boundaries"
                            "#d4b43e", # "geographic_boundaries eco_biogeo_proxies"
                            "#d4b43e", # "geographic_boundaries management_units" 
                            "#b34656", # "management_units" 
                            "#be72c9", # "other" 
                            "#be72c9")# "other_combinations" 

grouped_taxon_colors<-c("#9f43c8", "#91c637", "#e5463c")
  
```

## Get data 

Get indicators and metadata data from clean kobo output
```{r, echo=TRUE}
# Get data:
kobo_clean<-read.csv(file="kobo_output_clean.csv", header=TRUE)

# Extract indicator 1 data from kobo output, show most relevant columns
ind1_data<-get_indicator1_data(kobo_output=kobo_clean)
head(ind1_data[,c(1:3, 12:14)])

# Extract Proportion of maintained populations (indicator) data from kobo output, show most relevant columns
ind2_data<-get_indicator2_data(kobo_output=kobo_clean)
head(ind2_data[,c(1:3, 9:10,13)])

# Extract indicator 3 data from kobo output, show most relevant columns
ind3_data<-get_indicator3_data(kobo_output=kobo_clean)
head(ind3_data[,c(1:3, 9:11)])

# extract metadata, show most relevant columns
metadata<-get_metadata(kobo_output=kobo_clean)
head(metadata[,c(1:3, 12, 25,26, 64)])
```

Get population data for those species assessed using the tabular text template instead of Kobo. This file was produced by the script `1.2_cleaning.Rmd`
```{r}
ind1_data_from_templates<-read.csv(file="ind1_data_from_templates.csv")

```

Add data recorded using the population template to the ind1_data already in the nice format.
```{r}
ind1_data<-rbind(ind1_data, ind1_data_from_templates)
```


## Estimate indicators

### Indicator 1 (proportion of populations with Ne >500):

Show most relevant columns of indicator 1 data
```{r}
head(ind1_data[,c(1:3, 12:14)])

```

Remember what the function to transform NcRange and NcPoint data into Ne does:
```{r}
# check what the custom funciton does
transform_to_Ne
```

Use function to get Ne data from NcRange or NcPoint data, and their combination (Ne estimated from Ne if Ne is available, otherwise, from Nc)

```{r}
ind1_data<-transform_to_Ne(ind1_data = ind1_data, ratio = 0.1)
```

Remember what the function to estimate indicator 1 does:
```{r}
# check what the custom function does
estimate_indicator1
```

**Now estimate indicator 1 :)**

```{r}
indicator1<-estimate_indicator1(ind1_data = ind1_data)
```

### Proportion of maintained populations (indicator 2) = proportion of populations within species which are maintained.

Proportion of maintained populations (indicator) is the he proportion of populations within species which are maintained. This can be estimated based on the `n_extant_populations` and `n_extint_populations`, as follows:

```{r}
ind2_data$indicator2<- ind2_data$n_extant_populations / (ind2_data$n_extant_populations + ind2_data$n_extint_populations)
head(ind2_data$indicator2)
```

### Number of taxa with genetic monitoring squemes (indicator3)

Indicator 3 refers to the number (count) of taxa by country in which genetic monitoring is occurring. This is stored in the variable `temp_gen_monitoring` as a "yes/no" answer for each taxon, so to estimate the indicator, we only need to count how many said "yes", keeping only one of the records when the taxon was multiassessed:

```{r}
indicator3<-ind3_data %>%
                 # keep only one record if the taxon was assessed more than once within the country
                 select(country_assessment, taxon, temp_gen_monitoring) %>%
                 filter(!duplicated(.)) %>%

                 # count "yes" in tem_gen_monitoring by country
                 filter(temp_gen_monitoring=="yes") %>%
                 group_by(country_assessment) %>%
                 summarise(n_taxon_gen_monitoring= n())
```

### Join indicators and metadata in a single table

It could be useful to have the estimated indicator and the metadata in a single large table.
```{r}
indicators_full<-left_join(metadata, indicator1) %>% 
                     left_join(ind2_data) %>% 
                     left_join(ind3_data)
```

### Save indicators data
Save indicators data and metadata to csv files, useful for analyses outside R.

```{r}
# save processed data
write.csv(ind1_data, "ind1_data.csv", row.names = FALSE)
write.csv(indicators_full, "indicators_full.csv", row.names = FALSE)
write.csv(ind2_data, "ind2_data.csv", row.names = FALSE)
write.csv(ind3_data, "ind3_data.csv", row.names = FALSE)
write.csv(metadata, "metadata.csv", row.names = FALSE)

```


## Change country name to nicer labels

To have nice levels in the plots we will change the way country names are written: 

```{r nice country names}
# make factor
metadata$country_assessment<-as.factor(metadata$country_assessment)
indicators_full$country_assessment<-as.factor(indicators_full$country_assessment)
ind2_data$country_assessment<-as.factor(ind2_data$country_assessment)
ind1_data$country_assessment<-as.factor(ind1_data$country_assessment)
indicator1$country_assessment<-as.factor(indicator1$country_assessment)

# original levels
levels(metadata$country_assessment)

# change
levels(metadata$country_assessment)<-c("Australia", "Belgium", "Colombia", "France", "Japan", "Mexico", "S. Africa", "Sweden", "US")
levels(indicators_full$country_assessment)<-c("Australia", "Belgium", "Colombia", "France", "Japan", "Mexico", "S. Africa", "Sweden", "US")
levels(ind1_data$country_assessment)<-c("Australia", "Belgium", "Colombia", "France", "Japan", "Mexico", "S. Africa", "Sweden", "US")
levels(ind2_data$country_assessment)<-c("Australia", "Belgium", "Colombia", "France", "Japan", "Mexico", "S. Africa", "Sweden", "US")
levels(indicator1$country_assessment)<-c("Australia", "Belgium", "Colombia", "France", "Japan", "Mexico", "S. Africa", "Sweden", "US")


```


## Simplify combinations of methods to define populations

The methods used to define populations come from a check box question were one or more of the following categories can be selected: genetic_clusters, geographic_boundaries, eco_biogeo_proxies, adaptive_traits, management_units, other. As a consequence any combination of the former can be possible. Leading to the following frequency table:

```{r}
table(indicators_full$defined_populations)
```

It is hard to group the above methods, so we will keep the original groups with n >=19 in the above list, and tag the combinations that appear few times as as "other_combinations".

Which groups have n>=19?
```{r}
x<-as.data.frame(table(indicators_full$defined_populations)[table(indicators_full$defined_populations) >= 19])
colnames(x)[1]<-"method"

x

```

We can add this new column to the metadata and indicator data:

```{r} 
### for indicators 
indicators_full<- indicators_full %>% 
  mutate(defined_populations_simplified = case_when(
         # if the method is in the list of methods n>=19 then keep it
         defined_populations %in% x$method ~ defined_populations,
         TRUE ~ "other_combinations"))


### for meta
metadata<- metadata %>% 
  mutate(defined_populations_simplified = case_when(
         # if the method is in the list of methods n>=19 then keep it
         defined_populations %in% x$method ~ defined_populations,
         TRUE ~ "other_combinations"))

### for ind1 raw data
ind1_data<- ind1_data %>% 
  mutate(defined_populations_simplified = case_when(
         # if the method is in the list of methods n>=19 then keep it
         defined_populations %in% x$method ~ defined_populations,
         TRUE ~ "other_combinations"))
         
```


Check n for simplified methods:

```{r}
table(indicators_full$defined_populations_simplified)
```

Table of equivalences:

```{r}
indicators_full %>% 
       select(defined_populations, defined_populations_simplified) %>% 
       filter(!duplicated(defined_populations))
```

Create nicer names for ploting
```{r}
# original method names
levels(as.factor(indicators_full$defined_populations_simplified))


# nicer names
nice_names <- c("dispersal buffer",
                "eco- biogeographic proxies",
                 "genetic clusters",
                 "genetic clusters & eco- biogeographic proxies",
                 "genetic clusters & geographic boundaries",
                 "geographic boundaries",
                 "geographic boundaries & eco- biogeographic proxies",
                 "geographic boundaries & management units",
                 "management units",
                 "other", 
                 "other combinations")


### add them
indicators_full$defined_populations_nicenames <- factor(
    indicators_full$defined_populations_simplified,
    levels = levels(as.factor(indicators_full$defined_populations_simplified)),
    labels = nice_names)

# metadata
metadata$defined_populations_nicenames <- factor(
    metadata$defined_populations_simplified,
    levels = levels(as.factor(metadata$defined_populations_simplified)),
    labels = nice_names)

#check names match
select(metadata, defined_populations_nicenames, defined_populations_simplified)
levels(indicators_full$defined_populations_nicenames)
```



## Averaging multiassessments
Some taxa were assessed twice or more times, for example to account for uncertainty on how to divide populations. This information is stored in variable `multiassessment` of the metadata (created by `get_metadata()`). An example of taxa with multiple assessments:

```{r}
metadata %>%
filter(multiassessment=="multiassessment")  %>%
  select(taxonomic_group, taxon, country_assessment, multiassessment) %>%
  arrange(taxon, country_assessment) %>%
  head()
  
```

Multiassessments allow to account for uncertainty in the number of populations or the size of them. We can examine how the indicators value species by species as done elsewhere in these analyses (see below "Values for indicator 1 and 2 for multiassessed species), but to examine global trends, some of the figures below use the average. **The averages are stored in a different column, labeled `indicator[1 or 2]_mean`.**

```{r}
indicators_averaged<-indicators_full %>%
  # group desired multiassessments
  group_by(country_assessment, multiassessment, taxon) %>%
  # estimate means
  mutate(indicator1_mean=mean(indicator1, na.rm=TRUE)) %>%
  mutate(indicator2_mean=mean(indicator2, na.rm=TRUE)) %>%
  # change NaN for NA (needed due to the NAs and 0s in the dataset)
  mutate_all(~ifelse(is.nan(.), NA, .)) 
```

Examples of how this looks to check it was done properly. For indicator 1:
```{r}
indicators_averaged %>%
  filter(taxon == "Barbastella barbastellus") %>%
  select(taxon, country_assessment, multiassessment, indicator1, indicator1_mean)

indicators_averaged %>%
  filter(taxon == "Rana dalmatina") %>%
  select(taxon, country_assessment, multiassessment, indicator1, indicator1_mean)


indicators_averaged %>%
  filter(taxon == "Ambystoma cingulatum") %>%
  select(taxon, country_assessment, multiassessment, indicator1, indicator1_mean)
```

For Proportion of maintained populations (indicator):
```{r}
indicators_averaged %>%
  filter(taxon == "Ambystoma cingulatum") %>%
  select(taxon, country_assessment, multiassessment, indicator2, indicator2_mean)

```

Because we will use the averages to show a single value for multiasssessed taxa, we can keep only the first record for multiassessed taxa.
```{r}
indicators_averaged_one<-indicators_averaged[!duplicated(cbind(indicators_averaged$taxon, indicators_averaged$country_assessment)), ]
```



## General description of records and taxa assessed by country

Records by country, including taxa assessed more than once (see below for details on this)

```{r  taxa by country, out.width="700px", out.height="400px"}
ggplot(metadata, aes(x=country_assessment)) + 
  geom_bar(stat = "count") +
  xlab("") +
  ggtitle("Number of taxa assessed by country, including taxa assed more than once") +
  theme_light()

```

To explore what kind of taxa countries assessed regardless of if they assessed them once or more, we are going to use the subset `indicators_averaged_one`, were we averaged the indicators and kept only 1 record per assessment. 

How many taxa were assessed (i.e. counting only once taxa that were assessed multiple times)?
```{r}
# how many?
nrow(indicators_averaged_one)
```

Plot taxa assessed excluding duplicates, i.e. the real number of taxa assessed:

```{r, out.width="700px", out.height="400px"}
ggplot(indicators_averaged_one, aes(x=country_assessment)) + 
  geom_bar(stat = "count") +
  xlab("") +
  ggtitle("Number of taxa assessed by country") +
  theme_light()

```

Of which countries and taxonomic groups are the taxa that were assessed more than once?
```{r multiassessed}
indicators_averaged_one %>% # we use the _unique dataset so that multiassesed records are counted only once
        filter(multiassessment=="multiassessment") %>%

ggplot(aes(x=taxonomic_group, fill=country_assessment)) + 
  geom_bar(stat = "count") +
  theme(axis.text.x = element_text(angle = 45)) +
  labs(fill="Country") +
  xlab("") +
  ggtitle("Number of taxa assessed more than once") +
  theme_light()


```

## Population size data (Has Nc or Ne? what type of Nc?)

### Population size data availability by country
Countries have population size data (Nc or Ne) regardless of the taxonomic group.

```{r}
ggplot(metadata, aes(x=taxonomic_group, fill=popsize_data)) + 
  geom_bar(stat = "count") +
  coord_flip() +
  facet_wrap(~country_assessment, ncol = 5) +
  scale_fill_manual(values=c("#2ca02c", "#1f77b4", "grey80"),
                    breaks=c("yes", "data_for_species", "insuff_data_species"),
                    labels=c("Population level", "Species or subspecies level", "Insufficient data")) +
  labs(fill="Population size data availability",
       x="",
       y="Number of taxa (including records of taxa assessed more than once)") +
  theme_light() +
  theme(panel.border = element_blank(), legend.position="top")
  
```

Same plot but including a panel for the entire dataset:

```{r}
## Duplicate data with an additional column "facet"

df<-CreateAllFacet(metadata, "country_assessment")

# order with "all" as last
df$facet <- factor(df$facet, levels=c("Australia", "Belgium", "Colombia", "France", "Japan", "Mexico", "S. Africa", "Sweden", "US", "all"))

# Plot
ggplot(df, aes(x=taxonomic_group, fill=popsize_data)) + 
  geom_bar(stat = "count") +
  coord_flip() +
  facet_wrap(~facet, ncol = 5, scales="free_x") +
  scale_fill_manual(values=c("#2ca02c", "#1f77b4", "grey80"),
                    breaks=c("yes", "data_for_species", "insuff_data_species"),
                    labels=c("Population level", "Species or subspecies level", "Insufficient data")) +  labs(fill="Population size data availability",
       x="",
       y="Number of taxa (including records of taxa assessed more than once)") +
  theme_light() +
  theme(panel.border = element_blank(), legend.position="top")

```

Population size data availability in the entire dataset:
```{r}
ggplot(metadata, aes(x=taxonomic_group, fill=popsize_data)) + 
  geom_bar(stat = "count") +
  coord_flip() +
  scale_fill_manual(values=c("#1f77b4", "grey80", "#2ca02c"),
                    breaks=c(levels(as.factor(metadata$popsize_data))),
                                        labels=c("Species level or subspecies level", "Insufficient data", "Population level")) +
  labs(fill="Population size data availability",
       x="",
       y="Number of taxa (including records of taxa assessed more than once)") +
  theme_light() +
  theme(legend.position="right")
```


### Ne data yes or not? & Type of Nc data 

Ne available by taxa? (species level)
```{r}
p1<- metadata %>% 
  filter(!is.na(ne_pops_exists)) %>% 
  filter(ne_pops_exists!="other_genetic_info") %>%
    ggplot(aes(x=country_assessment, fill=ne_pops_exists)) + 
  geom_bar() +
scale_fill_manual(labels=c("no", "yes"),
                      breaks=c("no_genetic_data", "ne_available"),
                      values=c("#ff7f0e", "#2ca02c")) +
xlab("") +
ylab("Number of taxa") +
labs(fill="Ne available \n(from genetic data)")  +
theme_light() +
theme(text = element_text(size = 13), legend.position = "right", panel.border = element_blank())

p1

```

Nc data available by taxa? (species level)
```{r}
p2<-metadata %>%
  filter(!is.na(nc_pops_exists)) %>%
    ggplot(aes(x=country_assessment, fill=nc_pops_exists)) +
    geom_bar() +
    scale_fill_manual(values=c("#ff7f0e", "#2ca02c")) + 
    labs(fill="Nc available") +
    xlab("") +
    ylab("Number of taxa") +
    theme_light() +
    theme(text = element_text(size = 13), legend.position = "right", panel.border = element_blank())
p2
```


What kind of Nc data? (dodge bars) This is at population level. 
```{r}
ind1_data %>%
  filter(!is.na(NcType)) %>%
  ggplot(aes(x=country_assessment, fill=NcType))+
  geom_bar(position = "dodge") +
  scale_fill_manual(labels=c("Point", "Range \nor qualitative", "Unknown"),
                      breaks=c("Nc_point", "Nc_range", "unknown"),
                      values=c("#0072B2", "#E69F00", "grey80")) +
  xlab("") +
  ylab("Number of populations") +
  labs(fill="Type of Nc data \nby population") +
  theme_light() +
  theme(text = element_text(size = 13), legend.position = "right", panel.border = element_blank())

 
```

What kind of Nc data? (fill bars). This is at population level. 

```{r}
p3<-ind1_data %>%
  filter(!is.na(NcType)) %>%
  ggplot(aes(x=country_assessment, fill=NcType))+
  geom_bar(position = "fill", color="white") +
  scale_fill_manual(labels=c("Point", "Range \nor qualitative", "Unknown"),
                      breaks=c("Nc_point", "Nc_range", "unknown"),
                      values=c("#0072B2", "#E69F00", "grey80")) +
  xlab("") +
  ylab("Proportion of populations") +
  labs(fill="Type of Nc data \nby population") +
  theme_light() +
  theme(text = element_text(size = 13), legend.position = "right", panel.border = element_blank())
p3
 
```

### Data availability at the population level cosidering Ne or Nc combined (ie where data came from for the Ne value used for estimating the indicator)

```{r}
p4<-ind1_data %>%
    mutate(Ne_calculated_from = replace_na(Ne_calculated_from, "no data available")) %>%
  ggplot(aes(x=country_assessment, fill=Ne_calculated_from))+
  geom_bar(position = "fill", color="white") +
  scale_fill_manual(labels=c("genetic data", "NcPoint ratio", "NcRange ratio", "no data available"),
                      breaks=c("genetic data", "NcPoint ratio", "NcRange ratio", "no data available"),
                      values=c("darkgreen", "#0072B2", "#E69F00", "grey80")) +
  xlab("") +
  ylab("Proportion of populations") +
  labs(fill="Origin of data used to estimate Ne") +
  theme_light() +
  theme(text = element_text(size = 13), legend.position = "right", panel.border = element_blank())
p4


```

## Range of values for Ne and Nc data

Range of Ne values by taxonomic group, without possible outliers (Ne > 100000)

```{r}
ind1_data %>%
  filter(Ne < 100000) %>%
  filter(!is.na(Ne))  %>%
  
  ggplot(aes(x=taxonomic_group, y=Ne)) +
  geom_boxplot(color="grey50") +
  geom_jitter(size=.5, width = 0.1, color="darkred") +
  xlab("") +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45))
```

Check outliers
```{r}
ind1_data %>% 
  filter(Ne > 100000) %>%
  select(country_assessment, name_assessor, taxon, taxonomic_group, Ne, NeLower, NeUpper, multiassessment, population)
```


Range of Nc values (actual data point provided) by taxonomic group. Without possible outliers.

```{r}
ind1_data %>%
  filter(!is.na(NcPoint))  %>%
  filter(NcPoint < 10000000) %>%
 
  ggplot(aes(x=taxonomic_group, y=NcPoint)) +
  geom_boxplot(color="grey50") +
  geom_jitter(size=.5, width = 0.1, color="darkred") +
  xlab("") +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45))
```

Check outliers
```{r}
ind1_data %>% 
  filter(NcPoint > 10000000) %>% 
  select(country_assessment, name_assessor, taxon, taxonomic_group, population, NcPoint, NcLower, NcUpper, multiassessment, population)
```

Range of Ne values by taxonomic group from different sources. Without possible outliers.

```{r}
ind1_data %>%
  filter(!is.na(Ne_combined))  %>%
  filter(Ne < 100000) %>%
 
  ggplot(aes(x=taxonomic_group, y=Ne_combined)) +
  geom_boxplot(color="grey50") +
  geom_jitter(size=.5, width = 0.1, color="darkred") +
  xlab("") +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45))
```

Range of Ne values by taxonomic group from different sources. Zoom to Ne < 10,000

```{r}
ind1_data %>%
  filter(!is.na(Ne_combined))  %>%
  filter(Ne < 10000) %>%
 
  ggplot(aes(x=taxonomic_group, y=Ne_combined)) +
  geom_boxplot(color="grey50") +
  geom_jitter(size=.5, width = 0.1, color="darkred") +
  xlab("") +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45))
```

## Missing data on extant and extinct populations

We have NA in Proportion of maintained populations (indicator) because in some cases the number of extinct populations is unknown, therefore the operation cannot be computed. 

### Counts
Total records with NA in extant populations:
```{r}
sum(is.na(indicators_full$n_extant_populations))
```

Taxa with NA in extant populations:
```{r}
indicators_full %>%
  filter(is.na(n_extant_populations)) %>%
    select(country_assessment, taxonomic_group, taxon, n_extant_populations, n_extint_populations)
```

Total taxa with NA in **extinct** populations:
```{r}
sum(is.na(indicators_full$n_extint_populations))
```

Do taxa with NA for extant also have NA for extinct?

```{r}
indicators_full$taxon[is.na(indicators_full$n_extant_populations)] %in% indicators_full$taxon[is.na(indicators_full$n_extint_populations)]
```

So out of the `r nrow(indicators_full)`, we have **`r sum(is.na(indicators_full$n_extint_populations))` records with NA in n_extinct** and **`r sum(is.na(indicators_full$n_extant_populations))` records with NA in n_extant**. Of them, `r sum(indicators_full$taxon[is.na(indicators_full$n_extant_populations)] %in% indicators_full$taxon[is.na(indicators_full$n_extint_populations)])` have NA in both n_extant and n_extinct.


### Plot missing data extinct populations
```{r}
p5<-indicators_full %>%
  ggplot(aes(x=country_assessment, fill=is.na(n_extint_populations))) +
  geom_bar() +
  scale_fill_manual(labels=c("number of populations known", "missing data"),
                    values=c("#2ca02c", "#ff7f0e")) + 
  labs(fill="Extinct populations") +
  xlab("") + ylab("Number of taxa") +
  theme_light() +
  theme(text = element_text(size = 13), legend.position = "right", panel.border = element_blank())
p5
```


### Plot missing data extinct populations by country

Missing data in number of extinct populations by method to define populations:

```{r}
indicators_full %>%
  ggplot(aes(x=defined_populations_nicenames, fill=is.na(n_extint_populations)))+
  geom_bar() +
  coord_flip()+ 
  scale_fill_manual(labels=c("number of populations known", "missing data"),
                    values=c("#2ca02c", "#ff7f0e")) + 
  labs(fill="Extinct populations") +
  xlab("") + ylab("Number of taxa") +
  facet_wrap(country_assessment ~., nrow = 3, scales="free_x") +
  theme_light() +
  theme(panel.border = element_blank(), legend.position="top")
  
```

## Distribution of Nc, Ne, types of Nc and missing extinct pops in a single figure with 4 panels:

Distribution of Nc, Ne and types of Ne in a single figure with 3 panels, using count for a & b, and proportions for c:


```{r, out.width="900px", out.height="1100px"}
# plot
plot_grid(p1 + theme(legend.justification = c(0,.5)), # legend.justification aligns legends
          p2 + theme(legend.justification = c(0,.5)),
          p3 + theme(legend.justification = c(0,.5)),
          p4 + theme(legend.justification = c(0,.5)),
          ncol=1, rel_widths = c(1,1,1,1), align = "v", labels=c("a)", "b)", "c)", "d)"), vjust = .7)  
```


## Method to define populations used by country (alluvial)

Reformat data
```{r}
select(metadata, defined_populations_nicenames, defined_populations_simplified)


# reformat data
foralluvial<-metadata %>% group_by(country_assessment, defined_populations_nicenames, taxonomic_group) %>%
             summarise(n=n()) 

# define colors
my_cols<- simplifiedmethods_colors

# we need a vector of colors by country for each row of the dataset, so:
methodspop<-as.factor(foralluvial$defined_populations_nicenames)
levels(methodspop)<-my_cols
methodspop<-as.vector(methodspop)
head(methodspop)
```

Plot
```{r}
# plot
alluvial(foralluvial[,1:3], freq = foralluvial$n,
         col=methodspop, 
         blocks=FALSE,
         gap.width = 0.5,
         cex=.8, 
         xw = 0.1,
         cw = 0.2,
         border = NA,
         alpha = .7)

```


## Effect of method used to define populations on number of populations and PM and Ne>500 indicators

The analyses and plots below us a subset of data filtering outliers (>500 populations) and using the simplified methods (see above). Multiassessed species are considered independently (each assessment is a data point).

### Plot Number of maintained populations by country and method

Visualizing the Number of maintained populations by country and method is useful to interpret the models that would be run below.
```{r}
indicators_full %>% 
  filter(n_extant_populations<500) %>% # filter outliers
  # order countries vertically by similar number of pops
  mutate(country_assessment = factor(country_assessment, 
                                     levels=c("Colombia", "Australia", "Belgium",
                                               "Mexico", "France", "US", 
                                               "S. Africa", "Japan", "Sweden"))) %>%
  ggplot(aes(x=defined_populations_nicenames, y=n_extant_populations, 
             fill=defined_populations_nicenames, color=defined_populations_nicenames)) +
          geom_boxplot() +
          geom_jitter(size=.3, width = 0.1, color="black") +
  coord_flip() +
  facet_wrap(country_assessment ~ ., nrow=3, scales="free_x") +
  xlab("")  +
  ylab("Number of maintained populations") +
  scale_fill_manual(values=alpha(simplifiedmethods_colors, .3),
                    breaks=levels(as.factor(indicators_full$defined_populations_nicenames))) +
  scale_color_manual(values=simplifiedmethods_colors,
                    breaks=levels(as.factor(indicators_full$defined_populations_nicenames))) +
  scale_x_discrete(limits=rev) +
  theme_light() +
  theme(panel.border = element_blank(), legend.position="none",
        text = element_text(size = 15)) 



levels(indicators_full$country_assessment)
```

### Sampling size and plot of Ne values and Ne indicator by Ne origin and method to define populations


This is useful to interpret the models that would be run below. 
```{r}
ind1_data %>% 
  filter(Ne_combined < 100000) %>% # filter outliers

  ggplot(aes(x=defined_populations_simplified, y=Ne_combined, 
             color=Ne_calculated_from)) +
          geom_boxplot(position = "dodge") +
          geom_jitter(position = position_dodge(width = 0.75)) +  
          facet_wrap(country_assessment ~ ., nrow=3) +
          coord_flip() +
          theme_light()

```

Zoom to Ne 500
```{r}
ind1_data %>% 
  filter(Ne_combined < 100000) %>% # filter outliers

  ggplot(aes(x=defined_populations_simplified, y=Ne_combined, 
             color=Ne_calculated_from)) +
          ylim(0,2000)+
          geom_boxplot(position = "dodge") +
          geom_jitter(position = position_dodge(width = 0.75)) +  
          facet_wrap(country_assessment ~ ., nrow=3) +
          coord_flip() +
          theme_light()

```


Summary table for sampling size by method and source of Ne:
```{r}
x<- ind1_data %>% 
  filter(!is.na(Ne_calculated_from)) %>% 
  group_by(defined_populations_simplified, Ne_calculated_from) %>%
                summarise(n=n())
kable(x)
```

Same as above but adding country:
```{r}
x<- ind1_data %>% 
  filter(!is.na(Ne_calculated_from)) %>% 
  group_by(country_assessment, defined_populations_simplified, Ne_calculated_from) %>%
                summarise(n=n())
kable(x)
```




### (a) Does the number of maintained pops vary with method used? 

Plot number of populations by method
```{r, out.height="500px", out.width="1064px"}
# Prepare data for plot with nice labels:
# sample size of TOTAL populations
sample_size <- indicators_full %>%
                    filter(!is.na(n_extant_populations)) %>% 
                    filter(n_extant_populations<500) %>%
                    group_by(defined_populations_nicenames) %>% summarize(num=n())

# custom axis
## new dataframe
df<-indicators_full %>% 
  filter(!is.na(n_extant_populations)) %>% 
  filter(n_extant_populations<500) %>%
    # add sampling size 
  left_join(sample_size) %>%
  mutate(myaxis = paste0(defined_populations_nicenames, " (n= ", num, ")")) %>%
#myaxis needs levels in the same order than defined_populations_nicenames
  mutate(myaxis = factor(myaxis, 
                  levels=levels(as.factor(myaxis))[c(1,12,2:11,13)])) # reorders levels


# plot for number of pops
  p1<- df %>%
  ggplot(aes(x=myaxis, y=n_extant_populations, color=defined_populations_nicenames,
                                               fill=defined_populations_nicenames)) +
          geom_boxplot() + xlab("") + ylab("Number of maintained populations") +
          geom_jitter(size=.4, width = 0.1, color="black") +
  coord_flip() +
  theme_light() +
  theme(panel.border = element_blank(), legend.position="none",
        plot.margin = unit(c(0, 0, 0, 0), "cm")) + # this is used to decrease the space between plots
  scale_color_manual(values=simplifiedmethods_colors,
                    breaks=levels(as.factor(indicators_full$defined_populations_nicenames))) +
  scale_fill_manual(values=alpha(simplifiedmethods_colors, 0.3),
                    breaks=levels(as.factor(indicators_full$defined_populations_nicenames))) +
  scale_x_discrete(limits=rev) +  
  theme(text = element_text(size = 13))
p1

```

Try showing species range type:
```{r}
library(ggnewscale)
# points with species range type
  p1.1<- df %>%
  ggplot(aes(x=myaxis, y=n_extant_populations)) +
          geom_boxplot(aes(color=defined_populations_nicenames,
                           fill=defined_populations_nicenames)) + 
    xlab("") + ylab("Number of maintained populations") +
  coord_flip() +
  theme_light() +
  theme(panel.border = element_blank(), legend.position="none",
        plot.margin = unit(c(0, 0, 0, 0), "cm")) + # this is used to decrease the space between plots
  scale_color_manual(values=simplifiedmethods_colors,
                    breaks=levels(as.factor(indicators_full$defined_populations_nicenames))) +
  scale_fill_manual(values=alpha(simplifiedmethods_colors, 0.3),
                    breaks=levels(as.factor(indicators_full$defined_populations_nicenames))) +
  new_scale_color() +
  geom_jitter(size=1, width = 0.1, aes(color = species_range)) +
  theme(text = element_text(size = 13))

p1.1
```



Prepare data for model (remove outliers and NA in desired variable) and check n:
```{r}
# remove missing data 
data_for_model<-indicators_full %>% 
                      filter(!is.na(n_extant_populations)) %>%
                      filter(species_range !="unknown") %>% # we remove "unknonw" because its n is too low, thus unbalancing the model
                      filter(n_extant_populations<500) # doesn't make a difference in the test below, but useful for plots

# check n per method
table(data_for_model$defined_populations_simplified)

# total n
nrow(data_for_model)

# re-level to use geographic boundaries as reference category for the analysis
data_for_model$defined_populations_simplified<-relevel(as.factor(data_for_model$defined_populations_simplified),
                                                       ref="geographic_boundaries")

# make sure specis range is a factor
data_for_model$species_range<-as.factor(data_for_model$species_range)

```

Run model asking: Does the number of maintained pops vary with method used? Test controlling for variation in the number of maintaiend populations among countries:

```{r}
m1<-glmer(data_for_model$n_extant_populations ~ data_for_model$defined_populations_simplified + 
            (1|data_for_model$country_assessment), family ="poisson")
```

See results:
```{r}
summary(m1)
```

Controling for species range type (wide or restricted):

```{r}
m1.1<-glmer(data_for_model$n_extant_populations ~ data_for_model$defined_populations_simplified + data_for_model$species_range + (1|data_for_model$country_assessment), family ="poisson")

summary(m1.1)
```




### (b) Does the proportion of maintained populations (indicator2) vary with method used?

Plot

```{r}
# Prepare data for plot with nice labels:
# sample size of TOTAL populations
sample_size <- indicators_full %>%
                    filter(!is.na(indicator2)) %>% 
                    filter(n_extant_populations<500) %>% 
                    group_by(defined_populations_nicenames) %>% summarize(num=n())

# custom axis
## new dataframe
df<-indicators_full %>% 
  filter(n_extant_populations<500) %>%
  filter(!is.na(indicator2)) %>% 
    # add sampling size 
  left_join(sample_size) %>%
  mutate(myaxis = paste0(defined_populations_nicenames, " (n= ", num, ")")) %>%
#myaxis needs levels in the same order than defined_populations_nicenames
  mutate(myaxis = factor(myaxis, 
                  levels=levels(as.factor(myaxis))[c(1,12,2:11,13)])) # reorders levels



## plot for Proportion of maintained populations (indicator)
p2<- df %>%
  filter(n_extant_populations<500) %>%
  ggplot(aes(x=myaxis, y=indicator2, color=defined_populations_nicenames,    
                                     fill=defined_populations_nicenames)) +
          geom_boxplot() + xlab("") + ylab("Proportion of maintained populations") +
          geom_jitter(size=.4, width = 0.1, color="black") +
  coord_flip() +
  theme_light() +
  theme(panel.border = element_blank(), legend.position="none",
        plot.margin = unit(c(0, 0, 0, 0), "cm")) + # this is used to decrease the space between plots) 
  scale_fill_manual(values=alpha(simplifiedmethods_colors, 0.3),
                    breaks=levels(as.factor(indicators_full$defined_populations_nicenames))) +
  scale_color_manual(values=simplifiedmethods_colors,
                    breaks=levels(as.factor(indicators_full$defined_populations_nicenames))) +
  scale_x_discrete(limits=rev) +
  theme(text = element_text(size = 13))
p2

```

Try to show species range type
```{r}
p2.1<- df %>%
  filter(n_extant_populations<500) %>%
  ggplot(aes(x=myaxis, y=indicator2, color=defined_populations_nicenames,    
                                     fill=defined_populations_nicenames)) +
          geom_boxplot() + xlab("") + ylab("Proportion of maintained populations") +
  coord_flip() +
  theme_light() +
  theme(panel.border = element_blank(), legend.position="none",
        plot.margin = unit(c(0, 0, 0, 0), "cm")) + # this is used to decrease the space between plots) 
  scale_fill_manual(values=alpha(simplifiedmethods_colors, 0.3),
                    breaks=levels(as.factor(indicators_full$defined_populations_nicenames))) +
  scale_color_manual(values=simplifiedmethods_colors,
                    breaks=levels(as.factor(indicators_full$defined_populations_nicenames))) +
  scale_x_discrete(limits=rev) +
    new_scale_color() +
  geom_jitter(size=1, width = 0.1, aes(color = species_range)) +
  theme(text = element_text(size = 13))
p2.1

```


Prepare data for model (remove outliers and NA in desired variable) and check n:
```{r}
# remove missing data 
data_for_model<-indicators_full %>% 
                      filter(!is.na(indicator2)) %>%
                      filter(n_extant_populations<500) # doesn't make a difference in the test below, but useful for plots

# check n per method
table(data_for_model$defined_populations_simplified)

# total n
nrow(data_for_model)

# re-level to use geographic boundaries as reference category for the analysis
data_for_model$defined_populations_simplified<-relevel(as.factor(data_for_model$defined_populations_simplified),
                                                       ref="geographic_boundaries")

```

Run model asking: Does indicator 2 vary with method used? Controlling for variation in indicator2 among countries:


```{r}
m2<-glmmTMB(indicator2 ~ defined_populations_simplified + (1|country_assessment), family = "ordbeta", data = data_for_model)
```

See results:
```{r}
summary(m2)
```

### (c) Does the proportion of populations with Ne>500 (indicator1) vary with method used?

Plot

```{r}
# Prepare data for plot with nice labels:
# sample size of TOTAL populations
sample_size <- indicators_full %>%
                    filter(!is.na(indicator1)) %>% 
                    filter(n_extant_populations<500) %>% 
                    group_by(defined_populations_nicenames) %>% summarize(num=n())

# custom axis
## new dataframe
df<-indicators_full %>% 
  filter(n_extant_populations<500) %>%
  filter(!is.na(indicator1)) %>% 
    # add sampling size 
  left_join(sample_size) %>%
  mutate(myaxis = paste0(defined_populations_nicenames, " (n= ", num, ")")) %>%
#myaxis needs levels in the same order than defined_populations_nicenames
  mutate(myaxis = factor(myaxis, 
                  levels=levels(as.factor(myaxis))[c(1,12,2:11,13)])) # reorders levels



## plot 
p3<- df %>%
  ggplot(aes(x=myaxis, y=indicator1, color=defined_populations_nicenames,    
                                     fill=defined_populations_nicenames)) +
          geom_boxplot() + xlab("") + ylab("Proportion of populations with Ne>500") +
          geom_jitter(size=.4, width = 0.1, color="black") +
  coord_flip() +
  theme_light() +
  theme(panel.border = element_blank(), legend.position="none",
        plot.margin = unit(c(0, 0, 0, 0), "cm")) + # this is used to decrease the space between plots) 
  scale_fill_manual(values=alpha(simplifiedmethods_colors, 0.3),
                    breaks=levels(as.factor(indicators_full$defined_populations_nicenames))) +
  scale_color_manual(values=simplifiedmethods_colors,
                    breaks=levels(as.factor(indicators_full$defined_populations_nicenames))) +
  scale_x_discrete(limits=rev) +
  theme(text = element_text(size = 13))
p3

```

Prepare data for model (remove outliers and NA in desired variable) and check n:
```{r}
# remove missing data 
data_for_model<-indicators_full %>% 
                      filter(!is.na(indicator1)) %>%
                      filter(n_extant_populations<500) # doesn't make a difference in the test below, but useful for plots

# check n per method
table(data_for_model$defined_populations_simplified)

# total n
nrow(data_for_model)

# re-level to use geographic boundaries as reference category for the analysis
data_for_model$defined_populations_simplified<-relevel(as.factor(data_for_model$defined_populations_simplified),
                                                       ref="geographic_boundaries")

```

Run model asking: Does indicator 1 vary with method used? Controlling for variation in indicator1 among countries:


```{r}
m3<-glmmTMB(indicator1 ~ defined_populations_simplified + (1|country_assessment), family = "ordbeta", data = data_for_model)
```

See results:
```{r}
summary(m3)
```



### (A) Is there a relationship between number of maintained populations and Indicator2, overall, and/or with some methods?

Scatter plot of indicator2 vs extant pops
```{r}
p4<- indicators_full %>%
  # filter outliers with too many pops and missing data
  filter(n_extant_populations<500) %>%
  filter(!is.na(indicator2)) %>%
  filter(!is.na(n_extant_populations)) %>%
  filter(species_range !="unknown") %>%
  
  # plot
    ggplot(aes(x=n_extant_populations, y=indicator2, color=defined_populations_nicenames)) +
    geom_point() +
    theme_light() +
    scale_color_manual(values=simplifiedmethods_colors,
                    breaks=levels(as.factor(indicators_full$defined_populations_nicenames))) +
    theme(legend.position = "none") +
    ylab("Proportion of maintained populations") +
    xlab("Number of maintained populations") +
    theme(text = element_text(size = 13))
p4

p4.1<- indicators_full %>%
  # filter outliers with too many pops and missing data
  filter(n_extant_populations<500) %>%
  filter(!is.na(indicator2)) %>%
  filter(!is.na(n_extant_populations)) %>%
  filter(species_range !="unknown") %>%
  
  # plot
    ggplot(aes(x=n_extant_populations, y=indicator2, color=species_range)) +
    geom_point() +
    theme_light() +
    theme(legend.position = "none") +
    ylab("Proportion of maintained populations") +
    xlab("Number of maintained populations") +
    theme(text = element_text(size = 13))
p4.1

```

Prepare data for model (remove outliers and NA in desired variable) and check n:
```{r}
# remove missing data 
data_for_model<-indicators_full %>% 
                      filter(!is.na(indicator2)) %>%
                      filter(!is.na(n_extant_populations)) %>%
                      filter(n_extant_populations<500) # doesn't make a difference in the test below, but useful for plots

# check number of methods
length(unique(data_for_model$defined_populations_simplified))

# check n per method
table(data_for_model$defined_populations_simplified)

# total n
nrow(data_for_model)

# re-level to use geographic boundaries as reference category for the analysis
data_for_model$defined_populations_simplified<-relevel(as.factor(data_for_model$defined_populations_simplified),
                                                       ref="geographic_boundaries")

```

Run model:

```{r}
# run model
m4 <- glmmTMB(indicator2 ~ defined_populations_simplified + n_extant_populations + defined_populations_simplified*n_extant_populations + (1|country_assessment), family = "ordbeta", data = data_for_model)

```

Summary:

```{r}
summary(m4)
```


We run a similar model than above, but limited to relationship of interest:

```{r}
m4.1 <- glmmTMB(indicator2 ~ n_extant_populations + (1|country_assessment), family = "ordbeta", data= data_for_model)

```

Summary:
```{r}
summary(m4.1)
```

Because “what’s a population and how do you define them?” is such an important question, we can also test the effect of methods alone. First, subset the data to only those taxa where a single method was used: 

```{r}
ind2_single_methods<-indicators_full %>% 
                      filter(!is.na(indicator2)) %>% 
                      filter(n_extant_populations<500) %>%  # doesn't make a difference in the test below, but useful for 
                      filter(defined_populations_simplified=="genetic_clusters" | 
                             defined_populations_simplified=="geographic_boundaries" |
                             defined_populations_simplified=="eco_biogeo_proxies" | 
                             defined_populations_simplified=="management_units" |
                             defined_populations_simplified=="dispersal_buffer")


# check number of methods
length(unique(ind2_single_methods$defined_populations_simplified))

# check n by method
table(ind2_single_methods$defined_populations_simplified)

# check n total
nrow(ind2_single_methods)

# re-level to use geographic boundaries as reference category for the analysis
ind2_single_methods$defined_populations_simplified<-relevel(as.factor(ind2_single_methods$defined_populations_simplified),
                                                       ref="geographic_boundaries")

 
```

Run model:

```{r}
# run model
m4.2 <- glm(ind2_single_methods$indicator2 ~ ind2_single_methods$n_extant_populations + 
            ind2_single_methods$defined_populations_simplified + 
            ind2_single_methods$n_extant_populations*ind2_single_methods$defined_populations_simplified, family = "quasibinomial")
```

Summary:

```{r}
summary(m4.2)
```


### (B) Is there a relationship between number of maintained populations and indicator1, overall, and/or with some methods?

Scatter plot of indicator1 vs extant pops
```{r}
p5<- indicators_full %>%
  # filter outliers with too many pops and missing data
  filter(n_extant_populations<500) %>%
  filter(!is.na(indicator1)) %>%
  filter(!is.na(n_extant_populations)) %>%
  filter(species_range !="unknown") %>%
  
  
  # plot
    ggplot(aes(x=n_extant_populations, y=indicator1, color=defined_populations_nicenames)) +
    geom_point() +
    theme_light() +
    scale_color_manual(values=simplifiedmethods_colors,
                    breaks=levels(as.factor(indicators_full$defined_populations_nicenames))) +
    theme(legend.position = "none") +
    ylab("Proportion of populations with Ne>500") +
    xlab("Number of maintained populations") +
    theme(text = element_text(size = 13))
p5


## Coloring by range 
p5.1<- indicators_full %>%
  # filter outliers with too many pops and missing data
  filter(n_extant_populations<500) %>%
  filter(!is.na(indicator1)) %>%
  filter(!is.na(n_extant_populations)) %>%
  filter(species_range !="unknown") %>%
  
  
  # plot
    ggplot(aes(x=n_extant_populations, y=indicator1, color=species_range)) +
    geom_point() +
    theme_light() +
    theme(legend.position = "none") +
    ylab("Proportion of populations with Ne>500") +
    xlab("Number of maintained populations") +
    theme(text = element_text(size = 13))
p5.1

```

Prepare data for model (remove outliers and NA in desired variable) and check n:
```{r}
# remove missing data 
data_for_model<-indicators_full %>% 
                      filter(!is.na(indicator1)) %>%
                      filter(!is.na(n_extant_populations)) %>%
                      filter(n_extant_populations<500) # doesn't make a difference in the test below, but useful for plots

# check number of methods
length(unique(data_for_model$defined_populations_simplified))

# check n per method
table(data_for_model$defined_populations_simplified)

# total n
nrow(data_for_model)

# re-level to use geographic boundaries as reference category for the analysis
data_for_model$defined_populations_simplified<-relevel(as.factor(data_for_model$defined_populations_simplified),
                                                       ref="geographic_boundaries")

```

Run model:

```{r}
# run model
m5 <- glmmTMB(indicator1 ~ defined_populations_simplified + n_extant_populations + defined_populations_simplified*n_extant_populations + (1|country_assessment), family = "ordbeta", data = data_for_model)
```

Summary:

```{r}
summary(m5)
```


We run a similar model than above, but limited to relationship of interest:



```{r}
# m5.1 pending to update when 4.1 is checked ok
```

Summary:
```{r}
# summary(m5.1)
```

Because “what’s a population and how do you define them?” is such an important question, we can also test the effect of methods alone. First, subset the data to only those taxa where a single method was used: 

```{r}
ind1_single_methods<-indicators_full %>% 
                      filter(!is.na(indicator1)) %>% 
                      filter(n_extant_populations<500) %>%  # doesn't make a difference in the test below, but useful for 
                      filter(defined_populations_simplified=="genetic_clusters" | 
                             defined_populations_simplified=="geographic_boundaries" |
                             defined_populations_simplified=="eco_biogeo_proxies" | 
                             defined_populations_simplified=="management_units" |
                             defined_populations_simplified=="dispersal_buffer")


# check number of methods
length(unique(ind1_single_methods$defined_populations_simplified))

# check n by method
table(ind1_single_methods$defined_populations_simplified)

# check n total
nrow(ind1_single_methods)

# re-level to use geographic boundaries as reference category for the analysis
ind1_single_methods$defined_populations_simplified<-relevel(as.factor(ind1_single_methods$defined_populations_simplified),
                                                       ref="geographic_boundaries")

 
```

Run model:

```{r, }
# run model
# m5.2 pending
```

Summary:

```{r}
# summary(m5.2) pending
```



### Single plot 3 panels box plots for the effect of method on: number of populations, proportion of maintained populations (indicator 2) and Proportion of populations with Ne>500 (indicator 1).

Plot in three panels. 
```{r, out.height="400px", out.width="1600px"}
##### plot for Proportion of maintained populations (indicator 2) only with n in axis labels

# sample size 
sample_size <- indicators_full %>%
                    filter(!is.na(indicator2)) %>% 
                    filter(n_extant_populations<500) %>% 
                    group_by(defined_populations_nicenames) %>% summarize(num=n())

# custom axis
## new dataframe
df<-indicators_full %>% 
  filter(n_extant_populations<500) %>%
  filter(!is.na(indicator2)) %>% 
    # add sampling size 
  left_join(sample_size) %>%
  mutate(myaxis = as.factor(paste0(defined_populations_nicenames, " (n= ", num, ")")))


p2.1<- df %>%
  filter(n_extant_populations<500) %>%
  ggplot(aes(x=myaxis, y=indicator2, color=defined_populations_nicenames,    
                                     fill=defined_populations_nicenames)) +
          geom_boxplot() + xlab("") + ylab("Proportion of maintained populations") +
          geom_jitter(size=.4, width = 0.1, color="black") +
  coord_flip() +
  theme_light() +
  theme(panel.border = element_blank(), legend.position="none",
        plot.margin = unit(c(0.2, 0.2, 0.2, 0.2), "cm")) + # this is used to decrease the space between plots) 
  scale_fill_manual(values=alpha(simplifiedmethods_colors, 0.3),
                    breaks=levels(as.factor(indicators_full$defined_populations_nicenames))) +
  scale_color_manual(values=simplifiedmethods_colors,
                    breaks=levels(as.factor(indicators_full$defined_populations_nicenames))) +
  
  scale_x_discrete(limits=rev, 
                   labels= rev(sub(".*(\\(n= \\d+\\))", "\\1", levels(df$myaxis)))) + # extract "(n = number)") and show them in reverse order
  theme(text = element_text(size = 13))


##### plot for Proportion populations Ne>500 (indicator 1) only with n in axis labels
# Prepare data for plot with nice labels:
# sample size of TOTAL populations
sample_size <- indicators_full %>%
  filter(!is.na(indicator1)) %>% 
  filter(n_extant_populations<500) %>% 
  group_by(defined_populations_nicenames) %>% summarize(num=n())

# custom axis
## new dataframe
df<-indicators_full %>% 
  filter(n_extant_populations<500) %>%
  filter(!is.na(indicator1)) %>% 
  # add sampling size 
  left_join(sample_size) %>%
  mutate(myaxis = as.factor(paste0(defined_populations_nicenames, " (n= ", num, ")")))


## plot 
p3.1<- df %>%
  ggplot(aes(x=myaxis, y=indicator1, color=defined_populations_nicenames,    
             fill=defined_populations_nicenames)) +
  geom_boxplot() + xlab("") + ylab("Proportion of populations with Ne>500") +
  geom_jitter(size=.4, width = 0.1, color="black") +
  coord_flip() +
  theme_light() +
  theme(panel.border = element_blank(), legend.position="none",
        plot.margin = unit(c(0.2, 0.2, 0.2, 0.2), "cm")) + # this is used to decrease the space between plots) 
  scale_fill_manual(values=alpha(simplifiedmethods_colors, 0.3),
                    breaks=levels(as.factor(indicators_full$defined_populations_nicenames))) +
  scale_color_manual(values=simplifiedmethods_colors,
                     breaks=levels(as.factor(indicators_full$defined_populations_nicenames))) +
  scale_x_discrete(limits=rev, 
                   labels= rev(sub(".*(\\(n= \\d+\\))", "\\1", levels(df$myaxis)))) + # extract "(n = number)") and show them in reverse order
  theme(text = element_text(size = 13))


## Plot 3 panels
plot_grid(p1, p2.1, p3.1, ncol=3, rel_widths = c(1.9,1,1), align = "h", labels=c("a)", "b)", "c)"))  



```

### Single figure 2 panels scatter plots number of populations vs indicators

```{r, out.height= "800px", out.width="500px"}
# plot
plot_grid(p4 + xlim(0,400) + xlab(""), # remove xlab from top plot and match x axis size
          p5+ xlim(0,400), 
          ncol=1, align = "v", labels=c("a)", "b)"))  

```


## Effect of distribution range (restricted vs wide) on the indicators

All the following plots and analyses consider the average of multiassessed species (variable `_mean`), so that they are shown only once.

To have nicer looking plots, change "wide_ranging" for "wide ranging":
```{r}
indicators_averaged_one$species_range<-gsub("wide_ranging", "wide ranging", indicators_averaged_one$species_range)
```


### Indicator 1 (Ne>5000)

Plot Indicator 1 by type of range in the entire dataset. Filtering NA in species range:

```{r indicator1 by range}
# get sample size by desired category
sample_size <- indicators_averaged_one  %>%
                    filter(!is.na(indicator1_mean)) %>% 
                    filter(!is.na(species_range)) %>% 
                    group_by(species_range) %>% summarize(num=n())

# plot
p1<-indicators_averaged_one %>% 
    filter(!is.na(indicator1_mean)) %>% 
    filter(!is.na(species_range)) %>% 
  # add sampling size 
  left_join(sample_size) %>% 
  mutate(myaxis = paste0(species_range, " (n= ", num, ")")) %>%

  # plot
  ggplot(aes(x=myaxis, y=indicator1_mean , fill=species_range)) +
      geom_violin(width=1, linewidth = 0)  +
      geom_jitter(size=.5, width = 0.1) +
      xlab("") + ylab("Proportion of populations with Ne>500") +
      coord_flip() +
      scale_fill_manual(breaks=c("wide ranging", "restricted", "unknown"),
                       labels=c("wide ranging", "restricted", "unknown"),
                       values=c("#00BFC4", "#F8766D", "grey80")) +
      theme_light() +
      theme(panel.border = element_blank(), legend.position="none", text= element_text(size=20))
p1
```

Plot Indicator 1 by country and type of range. Remove "unknown" and NA for better visualization.

```{r indicator1 by country and range}
### Duplicate dataframe to have a column with "all data" for faceting
df<-CreateAllFacet(indicators_averaged_one, "country_assessment")

# order with "all" as last
df$facet <- factor(df$facet, levels=c("Australia", "Belgium", "Colombia", "France", "Japan", "Mexico", "S. Africa", "Sweden", "US", "all"))

## plot
df  %>% 
  # filter out "unknown" range
  filter(species_range !="unknown") %>% 
  
# plot
ggplot(aes(x=species_range, y=indicator1_mean , fill=species_range)) +
      geom_violin(width=1, linewidth = 0)  +
      geom_jitter(size=.5, width = 0.1) +
      xlab("") + ylab("Proportion of populations with Ne>500") +
      coord_flip() +
      scale_x_discrete(breaks=c("wide ranging", "restricted"),
                        labels=c("wide ranging", "restricted")) +
      theme_light() +
      theme(panel.border = element_blank(), legend.position="none", text= element_text(size=15)) +
      facet_wrap(~facet, ncol = 5) +
      theme(panel.spacing = unit(1.5, "lines"))  
  
```

Test the effect of range type on Ne>500 indicator. Does the indicator vary between wide randing vs restricted distribution species? (keep only those categories and remove unknwon due to small sampling size)

```{r stats indicator1 and range}

## Remove unknown
data<- indicators_averaged_one  %>%
                    filter(!is.na(indicator1_mean)) %>% 
                    filter(species_range !="unknown")

# summary of indicator
summary(data$indicator1_mean)
  
## run model 
m1 <- glmmTMB(indicator1_mean ~ defined_populations_simplified + species_range + defined_populations_simplified*species_range + (1|country_assessment), family = "ordbeta", data = data)


# summary results
summary(m1)


## + country
m1.1 <- glmmTMB(indicator1_mean ~ defined_populations_simplified + species_range + (1|country_assessment), family = "ordbeta", data = data)


# summary results
summary(m1.1)


```


### Indicator 2 (mantained populations)

Plot Indicator 2 by type of range in the entire dataset. Filtering NA in species range:

```{r indicator2 by range}
# get sample size by desired category
sample_size <- indicators_averaged_one  %>%
                    filter(!is.na(indicator2_mean)) %>% 
                    filter(!is.na(species_range)) %>% 
                    group_by(species_range) %>% summarize(num=n())

# plot
p2<-indicators_averaged_one %>% 
    filter(!is.na(indicator2_mean)) %>% 
    filter(!is.na(species_range)) %>% 
  # add sampling size 
  left_join(sample_size) %>% 
  mutate(myaxis = paste0(species_range, " (n= ", num, ")")) %>%

  # plot
  ggplot(aes(x=myaxis, y=indicator2_mean , fill=species_range)) +
      geom_violin(width=1, linewidth = 0)  +
      geom_jitter(size=.5, width = 0.1) +
      xlab("") + ylab("Proportion of populations maintained") +
      coord_flip() +
      scale_fill_manual(breaks=c("wide ranging", "restricted", "unknown"),
                       labels=c("wide ranging", "restricted", "unknown"),
                       values=c("#00BFC4", "#F8766D", "grey80")) +
      theme_light() +
      theme(panel.border = element_blank(), legend.position="none", text= element_text(size=20))
p2
```

Plot Indicator 2 by country and type of range. We remove NA and unknown for better visualization.

```{r indicator2 by country and range}
### Duplicate dataframe to have a column with "all data" for faceting
df<-CreateAllFacet(indicators_averaged_one, "country_assessment")

# order with "all" as last
df$facet <- factor(df$facet, levels=c("Australia", "Belgium", "Colombia", "France", "Japan", "Mexico", "S. Africa", "Sweden", "US", "all"))

## plot
df  %>% 
  # filter out "unknown" range
  filter(species_range !="unknown") %>% 
  
# plot
ggplot(aes(x=species_range, y=indicator2_mean , fill=species_range)) +
      geom_violin(width=1, linewidth = 0)  +
      geom_jitter(size=.5, width = 0.1) +
      xlab("") + ylab("Proportion of populations maintained") +
      coord_flip() +
      theme_light() +
      theme(panel.border = element_blank(), legend.position="none", text= element_text(size=15)) +
      facet_wrap(~facet, ncol = 5) +
      theme(panel.spacing = unit(1.5, "lines"))  
  
```

Test the effect of range type on the proportion of maitained populations. Does the indicator vary between wide randing vs restricted distribution species? Consider only wide randing and restricted categores (ie remove unknown due to small sampling size)

```{r stats indicator2 and range}

## Remove unknown
data<- indicators_averaged_one  %>%
                    filter(!is.na(indicator2_mean)) %>% 
                    filter(species_range !="unknown")

# summary of indicator
summary(data$indicator2_mean)
  
  
## run model 
m2 <- glmmTMB(indicator2_mean ~ defined_populations_simplified + species_range + defined_populations_simplified*species_range + (1|country_assessment), family = "ordbeta", data = data)


# summary results
summary(m2)


## + country
m2.1 <- glmmTMB(indicator2_mean ~ defined_populations_simplified + species_range + (1|country_assessment), family = "ordbeta", data = data)


# summary results
summary(m2.1)


```



### Single plot PM and Ne indicators by range type
```{r,  out.height="900px", out.width="800px"}
plot_grid(p1, p2,  ncol=1, align = "v", labels=c("a)", "b)"))  
```



## Indicatros by threat status (IUCN Red List)

All the following plots and analyses consider the average of multiassessed species (variable `_mean`), so that they are shown only once.

### (a-b) Ne > 500 indicator and red list status

Plot indicator 1 by global IUCN in the entire dataset:

```{r indicator1 gobalIUCN}

## Global IUCN
## prepare data
# add sampling size
sample_size <- indicators_averaged_one %>%
               filter(!is.na(indicator1_mean)) %>% 
               filter(!is.na(global_IUCN)) %>% 
               group_by(global_IUCN) %>% summarize(num=n())

# new df 
df<- indicators_averaged_one %>% 
     filter(!is.na(indicator1_mean)) %>% 
     filter(!is.na(global_IUCN)) %>% 
        # add sampling size 
        left_join(sample_size) %>%
        mutate(myaxis = paste0(global_IUCN, " (n= ", num, ")"))


# change order of levels so that they are in the desired order
df$myaxis<-factor(df$myaxis, 
                  #grep is used below to get the sample size, which may change depending on the data
                  levels=c(grep("cr", unique(df$myaxis), value = TRUE),
                          grep("en", unique(df$myaxis), value = TRUE),
                          grep("vu", unique(df$myaxis), value = TRUE),
                          grep("nt", unique(df$myaxis), value = TRUE),
                          grep("lc", unique(df$myaxis), value = TRUE),
                          grep("dd", unique(df$myaxis), value = TRUE),
                          grep("not_assessed", unique(df$myaxis), value = TRUE),
                          grep("unknown", unique(df$myaxis), value = TRUE)))

df$global_IUCN<-factor(df$global_IUCN, levels=c("cr", "en", "vu", "nt", "lc", "dd", "not_assessed", "unknown"))


      
# plot
p1<-df %>%
    ggplot(aes(x=myaxis, y=indicator1_mean , fill=global_IUCN)) +
      geom_violin(width=1, linewidth = 0)  +
      geom_jitter(size=.5, width = 0.1) +
      xlab("") + ylab("Proportion of populations with Ne>500") +
      coord_flip() +
      scale_fill_manual(values= IUCNcolors, # iucn color codes
                        breaks=c(levels(df$global_IUCN))) +
      scale_x_discrete(limits=rev) +
      theme_light() +
      ggtitle("global Red List") +
      theme(panel.border = element_blank(), legend.position="none", 
            plot.title = element_text(hjust = 0.5), # center title
            text= element_text(size=15))
p1

```


Indicator 1 by regional IUCN. This EXCLUDES Mexico, USA and Australia because they don't use the Red List approach at the national or regional level.

```{r indicator1 regionalIUCN}
## Regional IUCN

## prepare data
# add sampling size
sample_size <- indicators_averaged_one %>%
               filter(!is.na(indicator1_mean)) %>% 
               filter(!is.na(regional_redlist)) %>% 
               filter(country_assessment %!in% c("Mexico", "US", "Australia")) %>% 
               group_by(regional_redlist) %>% summarize(num=n())

# new df 
df<- indicators_averaged_one %>% 
     filter(!is.na(indicator1_mean)) %>% 
     filter(!is.na(regional_redlist)) %>% 
     filter(country_assessment %!in% c("Mexico", "US", "Australia")) %>% 
        # add sampling size 
        left_join(sample_size) %>%
        mutate(myaxis = paste0(regional_redlist, " (n= ", num, ")"))

# change order of levels so that they are in the desired order
df$myaxis<-factor(df$myaxis, 
                  #grep is used below to get the sample size, which may change depending on the data
                  levels=c(grep("re", unique(df$myaxis), value = TRUE),
                          grep("cr", unique(df$myaxis), value = TRUE),
                          grep("en", unique(df$myaxis), value = TRUE),
                          grep("vu", unique(df$myaxis), value = TRUE),
                          grep("nt", unique(df$myaxis), value = TRUE),
                          grep("lc", unique(df$myaxis), value = TRUE),
                          grep("dd", unique(df$myaxis), value = TRUE),
                          grep("not_assessed", unique(df$myaxis), value = TRUE),
                          grep("unknown", unique(df$myaxis), value = TRUE)))

df$regional_redlist<-factor(df$regional_redlist, levels=c("re","cr", "en", "vu", "nt", "lc", "dd", "not_assessed", "unknown"))
      
# plot
p2<-df %>%
    ggplot(aes(x=myaxis, y=indicator1_mean , fill=regional_redlist)) +
      geom_violin(width=1.5, linewidth = 0)  +
      geom_jitter(size=.5, width = 0.1) +
      xlab("") + ylab("Proportion of populations with Ne>500") +
      coord_flip() +
      scale_fill_manual(values= IUCNcolors_regional, # iucn color codes
                        breaks=c(levels(df$regional_redlist))) +
      scale_x_discrete(limits=rev) +
      theme_light() +
      ggtitle("regional Red List") +
      theme(panel.border = element_blank(), legend.position="none", 
            plot.title = element_text(hjust = 0.5), # center title
            text= element_text(size=15))
p2


```

Indicator 1 by country and global IUCN

```{r indicator1 country globalIUCN}
## change order of levels so that categories match with the order of colors
indicators_averaged_one$global_IUCN<-factor(indicators_averaged_one$global_IUCN, levels=c("cr", "en", "vu", "nt", "lc", "dd", "not_assessed", "unknown"))


# plot
indicators_averaged_one %>% 
  filter(!is.na(regional_redlist)) %>%
  # plot
  ggplot(aes(x=global_IUCN, y=indicator1_mean, fill=global_IUCN)) +
      geom_violin(width=1, linewidth = 0)  +
      geom_jitter(size=.5, width = 0.1) +
      xlab("") + ylab("Proportion of populations with Ne>500") +
      coord_flip() +
      scale_fill_manual(values= IUCNcolors, # iucn color codes
                    breaks=c(levels(indicators_averaged_one$global_IUCN))) +
      scale_x_discrete(limits=rev) +
      theme_light() +
      ggtitle("global IUCN Redlist") +
      theme(panel.border = element_blank(), legend.position="none", 
            plot.title = element_text(hjust = 0.5), # center title
            text= element_text(size=13)) +
      facet_wrap(~country_assessment, ncol = 3) +
      theme(panel.spacing = unit(1.5, "lines"))
```

Indicator1 by regional IUCN Redlist, excluding US, Australia and Mexico becasue they don't have a regional IUCN redlist.

```{r indicator1 country regionalIUCN}
## change order of levels so that categories match with the order of colors
indicators_averaged_one$regional_redlist<-factor(indicators_averaged_one$regional_redlist, levels=c("re","cr", "en", "vu", "nt", "lc", "dd", "not_assessed", "unknown"))

# plot
indicators_averaged_one %>% 
  # filter US and Mx
  filter(country_assessment %!in% c("Mexico", "US", "Australia")) %>%
  filter(!is.na(regional_redlist)) %>%
  
  # plot
  ggplot(aes(x=regional_redlist, y=indicator1_mean, fill=regional_redlist)) +
      geom_violin(width=1, linewidth = 0)  +
      geom_jitter(size=.5, width = 0.1) +
      xlab("") + ylab("Proportion of populations with Ne>500") +
      coord_flip() +
      scale_fill_manual(values= IUCNcolors_regional, # iucn color codes
                    breaks=c(levels(indicators_averaged_one$regional_redlist))) +
      scale_x_discrete(limits=rev) +
      theme_light() +
      ggtitle("regional IUCN Redlist") +
      theme(panel.border = element_blank(), legend.position="none", 
            plot.title = element_text(hjust = 0.5), # center title
            text= element_text(size=15)) +
      facet_wrap(~country_assessment, ncol = 3) +
      theme(panel.spacing = unit(1.5, "lines"))
```


### (c-d) Does Proportion of Maintained Populations indicator varies with red list status?

Plot indicator 2 by global IUCN in the entire dataset:

```{r indicator2 gobalIUCN}

## Global IUCN
## prepare data
# add sampling size
sample_size <- indicators_averaged_one %>%
               filter(!is.na(indicator2_mean)) %>% 
               filter(!is.na(global_IUCN)) %>% 
               group_by(global_IUCN) %>% summarize(num=n())

# new df 
df<- indicators_averaged_one %>% 
     filter(!is.na(indicator2_mean)) %>% 
     filter(!is.na(global_IUCN)) %>% 
        # add sampling size 
        left_join(sample_size) %>%
        mutate(myaxis = paste0(global_IUCN, " (n= ", num, ")"))


# change order of levels so that they are in the desired order
df$myaxis<-factor(df$myaxis, 
                  #grep is used below to get the sample size, which may change depending on the data
                  levels=c(grep("cr", unique(df$myaxis), value = TRUE),
                          grep("en", unique(df$myaxis), value = TRUE),
                          grep("vu", unique(df$myaxis), value = TRUE),
                          grep("nt", unique(df$myaxis), value = TRUE),
                          grep("lc", unique(df$myaxis), value = TRUE),
                          grep("dd", unique(df$myaxis), value = TRUE),
                          grep("not_assessed", unique(df$myaxis), value = TRUE),
                          grep("unknown", unique(df$myaxis), value = TRUE)))

df$global_IUCN<-factor(df$global_IUCN, levels=c("cr", "en", "vu", "nt", "lc", "dd", "not_assessed", "unknown"))


      
# plot
p3<-df %>%
    ggplot(aes(x=myaxis, y=indicator2 , fill=global_IUCN)) +
      geom_violin(width=1, linewidth = 0)  +
      geom_jitter(size=.5, width = 0.1) +
      xlab("") + ylab("Proportion of maintained populations") +
      coord_flip() +
      scale_fill_manual(values= IUCNcolors, # iucn color codes
                        breaks=c(levels(df$global_IUCN))) +
      scale_x_discrete(limits=rev) +
      theme_light() +
      ggtitle("global Red List") +
      theme(panel.border = element_blank(), legend.position="none", 
            plot.title = element_text(hjust = 0.5), # center title
            text= element_text(size=15))
p3

```


indicator 2 by regional IUCN. This EXCLUDES Mexico, USA and Australia because they don't use the Red List approach at the national or regional level.

```{r indicator2 regionalIUCN}
## Regional IUCN

## prepare data
# add sampling size
sample_size <- indicators_averaged_one %>%
               filter(!is.na(indicator2_mean)) %>% 
               filter(!is.na(regional_redlist)) %>% 
               filter(country_assessment %!in% c("Mexico", "US", "Australia")) %>% 
               group_by(regional_redlist) %>% summarize(num=n())

# new df 
df<- indicators_averaged_one %>% 
     filter(!is.na(indicator2_mean)) %>% 
     filter(!is.na(regional_redlist)) %>% 
     filter(country_assessment %!in% c("Mexico", "US", "Australia")) %>% 
        # add sampling size 
        left_join(sample_size) %>%
        mutate(myaxis = paste0(regional_redlist, " (n= ", num, ")"))

# change order of levels so that they are in the desired order
df$myaxis<-factor(df$myaxis, 
                  #grep is used below to get the sample size, which may change depending on the data
                  levels=c(grep("re", unique(df$myaxis), value = TRUE),
                          grep("cr", unique(df$myaxis), value = TRUE),
                          grep("en", unique(df$myaxis), value = TRUE),
                          grep("vu", unique(df$myaxis), value = TRUE),
                          grep("nt", unique(df$myaxis), value = TRUE),
                          grep("lc", unique(df$myaxis), value = TRUE),
                          grep("dd", unique(df$myaxis), value = TRUE),
                          grep("not_assessed", unique(df$myaxis), value = TRUE),
                          grep("unknown", unique(df$myaxis), value = TRUE)))

df$regional_redlist<-factor(df$regional_redlist, levels=c("re","cr", "en", "vu", "nt", "lc", "dd", "not_assessed", "unknown"))
      
# plot
p4<-df %>%
    ggplot(aes(x=myaxis, y=indicator2_mean , fill=regional_redlist)) +
      geom_violin(width=1, linewidth = 0)  +
      geom_jitter(size=.5, width = 0.1) +
      xlab("") + ylab("Proportion of maintained populations") +
      coord_flip() +
      scale_fill_manual(values= IUCNcolors_regional, # iucn color codes
                        breaks=c(levels(df$regional_redlist))) +
      scale_x_discrete(limits=rev) +
      theme_light() +
      ggtitle("regional Red List") +
      theme(panel.border = element_blank(), legend.position="none", 
            plot.title = element_text(hjust = 0.5), # center title
            text= element_text(size=15))
p4


```

indicator 2 by country and global IUCN

```{r indicator2 country globalIUCN}
## change order of levels so that categories match with the order of colors
indicators_averaged_one$global_IUCN<-factor(indicators_averaged_one$global_IUCN, levels=c("cr", "en", "vu", "nt", "lc", "dd", "not_assessed", "unknown"))


# plot
indicators_averaged_one %>% 
  filter(!is.na(regional_redlist)) %>%
  # plot
  ggplot(aes(x=global_IUCN, y=indicator2_mean, fill=global_IUCN)) +
      geom_violin(width=1, linewidth = 0)  +
      geom_jitter(size=.5, width = 0.1) +
      xlab("") + ylab("Proportion of maintained populations") +
      coord_flip() +
      scale_fill_manual(values= IUCNcolors, # iucn color codes
                    breaks=c(levels(indicators_averaged_one$global_IUCN))) +
      scale_x_discrete(limits=rev) +
      theme_light() +
      ggtitle("global IUCN Redlist") +
      theme(panel.border = element_blank(), legend.position="none", 
            plot.title = element_text(hjust = 0.5), # center title
            text= element_text(size=13)) +
      facet_wrap(~country_assessment, ncol = 3) +
      theme(panel.spacing = unit(1.5, "lines"))
```

indicator2 by regional IUCN Redlist, excluding US, Australia and Mexico becasue they don't have a regional IUCN redlist.

```{r indicator2 country regionalIUCN}
## change order of levels so that categories match with the order of colors
indicators_averaged_one$regional_redlist<-factor(indicators_averaged_one$regional_redlist, levels=c("re","cr", "en", "vu", "nt", "lc", "dd", "not_assessed", "unknown"))

# plot
indicators_averaged_one %>% 
  # filter US and Mx
  filter(country_assessment %!in% c("Mexico", "US", "Australia")) %>%
  filter(!is.na(regional_redlist)) %>%
  
  # plot
  ggplot(aes(x=regional_redlist, y=indicator2_mean, fill=regional_redlist)) +
      geom_violin(width=1.5, linewidth = 0)  +
      geom_jitter(size=.5, width = 0.1) +
      xlab("") + ylab("Proportion of maintained populations") +
      coord_flip() +
      scale_fill_manual(values= IUCNcolors_regional, # iucn color codes
                    breaks=c(levels(indicators_averaged_one$regional_redlist))) +
      scale_x_discrete(limits=rev) +
      theme_light() +
      ggtitle("regional IUCN Redlist") +
      theme(panel.border = element_blank(), legend.position="none", 
            plot.title = element_text(hjust = 0.5), # center title
            text= element_text(size=15)) +
      facet_wrap(~country_assessment, ncol = 3) +
      theme(panel.spacing = unit(1.5, "lines"))
```

### Single plot 4 pannels IUCN redlist and indicator range values

```{r}
plot_grid(p1 + ylab(""),
          p3 + ylab(""),
          p2,
          p4,
          ncol=2, align = "v", labels=c("a)", "c)", "b)", "d)"))  
```

### How many taxa are below 0.75, 0.50 or 0.25 in indicators?

Table for the Ne > 500 indicator:

```{r}
x  <- indicators_averaged_one %>%
               filter(!is.na(indicator1_mean)) %>% 
               filter(!is.na(global_IUCN)) %>% 
               group_by(global_IUCN) %>% 
               summarize(n.Ne_ind=n(),
                         n.below.75=sum(indicator1_mean<0.75),
                         n.below.50=sum(indicator1_mean<0.50),
                         n.below.25=sum(indicator1_mean<0.25),
                         per.below.25=n.below.25/n.Ne_ind*100,
                         per.below.50=n.below.50/n.Ne_ind*100)
kable(x, digits=1)
```

Table for the PM indicator:

```{r}
x  <- indicators_averaged_one %>%
               filter(!is.na(indicator2_mean)) %>% 
               filter(!is.na(global_IUCN)) %>% 
               group_by(global_IUCN) %>% 
               summarize(n.PM_ind=n(),
                         n.below.75=sum(indicator2_mean<0.75),
                         n.below.50=sum(indicator2_mean<0.50),
                         n.below.25=sum(indicator2_mean<0.25),
                         per.below.25=n.below.25/n.PM_ind*100,
                         per.below.50=n.below.50/n.PM_ind*100)
kable(x, digits=1)
```



## Indicator values by taxonomic group

All the following plots and analyses consider the average of multiassessed species (variable _mean), so that they are shown only once. 

We also grouped taxa with small n (<5) into "others", according to the following table:

```{r}
table(indicators_averaged_one$taxonomic_group)
```

They are grouped along with "other" in a new category "others" in the new variable `taxonomic_group_simplified`:

```{r}
indicators_averaged_one <- indicators_averaged_one %>% 
                                mutate(taxonomic_group_simplified = case_when(
                                       # if the taxon group is in the list of groups with small n change to "others"
                                       taxonomic_group %!in% c("bryophyte", "fungus", "other") ~ taxonomic_group,
                                       TRUE ~ "others"))

# check:
table(indicators_averaged_one$taxonomic_group_simplified)
```


### Violin plots and summary tables for each indicator by taxonomic group

**Indicator Ne > 500**

```{r}
## prepare data
# add sampling size
sample_size <- indicators_averaged_one %>%
               filter(!is.na(indicator1_mean)) %>% 
               group_by(taxonomic_group_simplified) %>% summarize(num=n())

# new df 
df<- indicators_averaged_one %>% 
     filter(!is.na(indicator1_mean)) %>% 
        # add sampling size 
        left_join(sample_size) %>%
        mutate(myaxis = paste0(taxonomic_group_simplified, " (n= ", num, ")"))

# change order of levels so that they are in the desired order
df$myaxis<-factor(df$myaxis, 
                  #grep is used below to get the sample size, which may change depending on the data
                    levels=c(grep("amphibian", unique(df$myaxis), value = TRUE), 
                             grep("bird" , unique(df$myaxis), value = TRUE),
                             grep("fish" , unique(df$myaxis), value = TRUE),
                             grep("invertebrate", unique(df$myaxis), value = TRUE),
                             grep("mammal", unique(df$myaxis), value = TRUE),
                             grep("angiosperm", unique(df$myaxis), value = TRUE),
                             grep("gymnosperm", unique(df$myaxis), value = TRUE),
                             grep("reptile", unique(df$myaxis), value = TRUE),
                             grep("pteridophytes", unique(df$myaxis), value = TRUE),
                             grep("others" , unique(df$myaxis), value = TRUE)))

df$taxonomic_group_simplified<-factor(df$taxonomic_group_simplified, 
                                       levels=c("amphibian", "bird" , "fish" , "invertebrate", "mammal",
                                                 "angiosperm",  "gymnosperm",  "reptile", "pteridophytes",
                                                "others"))

        
# plot
p1<-df %>%
    ggplot(aes(x=myaxis, y=indicator1_mean, fill=taxonomic_group_simplified, color=taxonomic_group_simplified)) +
      geom_violin(width=1.5, linewidth = 0.2)  +
      geom_jitter(size=.7, width = 0.1, color="darkred") +
      xlab("") + ylab("Proportion of populations with Ne>500") +
      coord_flip() +
      scale_x_discrete(limits=rev) +
      scale_fill_manual(values= c(rep(grouped_taxon_colors[1], 5), # for animals
                                  rep(grouped_taxon_colors[2], 4), # for platns
                                  rep(grouped_taxon_colors[3], 1)), # for fungi and others
                       breaks=c(levels(df$taxonomic_group_simplified))) +
      scale_color_manual(values= c(rep(grouped_taxon_colors[1], 5), # for animals
                                  rep(grouped_taxon_colors[2], 4), # for platns
                                  rep(grouped_taxon_colors[3], 1)), # for fungi and others
                       breaks=c(levels(df$taxonomic_group_simplified))) +
      theme_light() +
      theme(panel.border = element_blank(), legend.position="none",
            text= element_text(size=15))
p1
```


Table with sampling size, mean indicator value and proporiton of taxa where the value is below 0.25, 0.50 and 0.75:

```{r}
#summary table by taxonomic group
x  <- indicators_averaged_one %>%
               filter(!is.na(indicator1_mean)) %>% 
               filter(!is.na(taxonomic_group_simplified)) %>% 
               group_by(taxonomic_group_simplified) %>% 
               summarize(n=n(),
                         mean=mean(indicator1_mean),
                         median=median(indicator1_mean),
                         n.below.75=sum(indicator1_mean<0.75),
                         n.below.50=sum(indicator1_mean<0.50),
                         n.below.25=sum(indicator1_mean<0.25),
                         per.below.25=n.below.25/n*100,
                         per.below.50=n.below.50/n*100)

# Calculate total counts and means
total_counts <- summarise(x,
                          taxonomic_group_simplified = "ALL",
                          n = sum(n),
                          mean= mean(mean),
                          median=median(median),
                          n.below.75 = sum(n.below.75),
                          n.below.50 = sum(n.below.50),
                          n.below.25 = sum(n.below.25),
                          per.below.25 = n.below.25 / n * 100,
                          per.below.50 = n.below.50 / n * 100)

# Bind the total row to the summary_table
summary_table <- bind_rows(x, total_counts)

# keep taxonomic groups as level in desired order:
summary_table$taxonomic_group_simplified<-factor(summary_table$taxonomic_group_simplified,
                                                 levels = c("amphibian", "bird" , "fish" , "invertebrate", "mammal",
                                                 "angiosperm", "gymnosperm",  "reptile", "pteridophytes",
                                                "others", "ALL"))
summary_table<- summary_table %>% arrange(taxonomic_group_simplified)

# show nice table
kable(summary_table, digits=2)
```



**Indicator Proportion of mantained populations:**

```{r}
## prepare data
# add sampling size
sample_size <- indicators_averaged_one %>%
               filter(!is.na(indicator2_mean)) %>% 
               group_by(taxonomic_group_simplified) %>% summarize(num=n())

# new df 
df<- indicators_averaged_one %>% 
     filter(!is.na(indicator2_mean)) %>% 
        # add sampling size 
        left_join(sample_size) %>%
        mutate(myaxis = paste0(taxonomic_group_simplified, " (n= ", num, ")"))

# change order of levels so that they are in the desired order
df$myaxis<-factor(df$myaxis, 
                  #grep is used below to get the sample size, which may change depending on the data
                    levels=c(grep("amphibian", unique(df$myaxis), value = TRUE), 
                             grep("bird" , unique(df$myaxis), value = TRUE),
                             grep("fish" , unique(df$myaxis), value = TRUE),
                             grep("invertebrate", unique(df$myaxis), value = TRUE),
                             grep("mammal", unique(df$myaxis), value = TRUE),
                             grep("angiosperm", unique(df$myaxis), value = TRUE),
                             grep("gymnosperm", unique(df$myaxis), value = TRUE),
                             grep("reptile", unique(df$myaxis), value = TRUE),
                             grep("pteridophytes", unique(df$myaxis), value = TRUE),
                             grep("others" , unique(df$myaxis), value = TRUE)))

df$taxonomic_group_simplified<-factor(df$taxonomic_group_simplified, 
                           levels=c("amphibian", "bird" , "fish" , "invertebrate", "mammal",
                                     "angiosperm",  "gymnosperm",  "reptile", "pteridophytes",
                                     "others"))

        
# plot
p2<-df %>%
    ggplot(aes(x=myaxis, y=indicator2_mean, fill=taxonomic_group_simplified, color=taxonomic_group_simplified)) +
      geom_violin(width=1, linewidth = 0.2)  +
      geom_jitter(size=.7, width = 0.1, color="darkred") +
      xlab("") + ylab("Proportion of maintained populations") +
      coord_flip() +
      scale_x_discrete(limits=rev) +
      scale_fill_manual(values= c(rep(grouped_taxon_colors[1], 5), # for animals
                                  rep(grouped_taxon_colors[2], 4), # for platns
                                  rep(grouped_taxon_colors[3], 1)), # for fungi and others
                       breaks=c(levels(df$taxonomic_group_simplified))) +
      scale_color_manual(values= c(rep(grouped_taxon_colors[1], 5), # for animals
                                  rep(grouped_taxon_colors[2], 4), # for platns
                                  rep(grouped_taxon_colors[3], 1)), # for fungi and others
                       breaks=c(levels(df$taxonomic_group_simplified))) +
      theme_light() +
      theme(panel.border = element_blank(), legend.position="none",
            text= element_text(size=15))
p2
```

Table with sampling size, mean indicator value and proporiton of taxa where the value is below 0.25, 0.50 and 0.75:


```{r}
# summary table for taxonomic group:
x  <- indicators_averaged_one %>%
               filter(!is.na(indicator2_mean)) %>% 
               filter(!is.na(taxonomic_group_simplified)) %>% 
               group_by(taxonomic_group_simplified) %>% 
               summarize(n=n(),
                         mean=mean(indicator2_mean),
                         median=median(indicator2_mean),
                         n.below.75=sum(indicator2_mean<0.75),
                         n.below.50=sum(indicator2_mean<0.50),
                         n.below.25=sum(indicator2_mean<0.25),
                         per.below.25=n.below.25/n*100,
                         per.below.50=n.below.50/n*100)


# Calculate total counts and means
total_counts <- summarise(x,
                          taxonomic_group_simplified = "ALL",
                          n = sum(n),
                          mean = mean(mean),
                          median = median(median),
                          n.below.75 = sum(n.below.75),
                          n.below.50 = sum(n.below.50),
                          n.below.25 = sum(n.below.25),
                          per.below.25 = n.below.25 / n * 100,
                          per.below.50 = n.below.50 / n * 100)

# Bind the total row to the summary_table
summary_table <- bind_rows(x, total_counts)

# keep taxonomic groups as level in desired order:
summary_table$taxonomic_group_simplified<-factor(summary_table$taxonomic_group_simplified,
                                                 levels = c("amphibian", "bird" , "fish" , "invertebrate", "mammal",
                                                 "angiosperm", "gymnosperm",  "reptile", "pteridophytes",
                                                "others", "ALL"))
summary_table<- summary_table %>% arrange(taxonomic_group_simplified)

# show nice table
kable(summary_table, digits=2)

```


### Single figure 2 panels violin plots for both indicators by taxonomic group
```{r}
plot_grid(p1, p2, ncol=1, align = "v", labels=c("a)", "b)"))
```

## Values of indicator 1 and indicator 2 for multiassessed species

```{r}
#subset only with taxa assessed multiple times:
only_multi<-indicators_full %>% 
                          filter(multiassessment=="multiassessment") 
```

First, check how indicator 1 changes across the multiassessments.

```{r}
p1<-only_multi %>% 
  # Keep rows with different values in indicator1 within each taxon group
  group_by(taxon) %>%
  filter(n_distinct(indicator1) > 1) %>%
  # plot
  ggplot(aes(x=taxon, y=indicator1)) +
          geom_line(colour="darkgrey") + 
          geom_point(aes(color=country_assessment)) +
  xlab("") + ylab("Proportion of populations with Ne>500") +
  labs(color="country") +
  ylim(0, 1)+
  coord_flip() +
  theme_light() + 
  theme(panel.border = element_blank(), legend.position="right", text= element_text(size=13))
p1

```

Now check how Proportion of maintained populations (indicator 2) changes across the multiassessments.

```{r}
p2<-only_multi %>% 
  # Keep rows with different values in indicator1 within each taxon group
  group_by(taxon) %>%
  filter(n_distinct(indicator2) > 1) %>%
  
  ggplot(aes(x=taxon, y=indicator2)) +
          geom_line(colour="darkgrey") + 
          geom_point(aes(color=country_assessment)) +
    scale_color_manual(values= scales::hue_pal()(4)[2:4]) + # last 3 colors to make them the same than the other plot
  xlab("") + ylab("Proportion of populations maintained") +
  labs(color="country") +
  coord_flip() +
  theme_light() + 
  theme(panel.border = element_blank(), legend.position="right", text= element_text(size=13))
p2
```

Plot together:
```{r}
plot_grid(p2, p1,  
          rel_heights = c(1.3, 0.9),
          ncol=1, labels=c("a)", "b)")) 
```



## Indicator 3 (number of species with genetic diversity monitoring)
Indicator 3 refers to the number (count) of taxa by country in which genetic monitoring is occurring. This is stored in the variable temp_gen_monitoring as a “yes/no” answer for each taxon.

```{r}
indicator3
```

Plot by global IUCN redlist status
```{r}
# desired order of levels
indicators_full$global_IUCN<-factor(as.factor(indicators_full$global_IUCN), levels=c("cr", "en", "vu", "nt", "lc", "dd", "not_assessed", "unknown"))


## plot
indicators_full %>%
                 # keep only one record if the taxon was assessed more than once within the country
                 select(country_assessment, taxon, temp_gen_monitoring, global_IUCN) %>%
                 filter(!duplicated(.)) %>%

                 # count "yes" in tem_gen_monitoring by country
                 filter(temp_gen_monitoring=="yes") %>%
ggplot(aes(x=country_assessment, fill=global_IUCN)) +
  geom_bar() +
  xlab("") + ylab("Number of taxa with temporal genetic diversity monitoring") +
  scale_fill_manual(values= IUCNcolors, # iucn color codes
                    breaks=levels(as.factor(indicators_full$global_IUCN))) +
      theme_light()
```

Relatively few taxa have genetic monitoring, but many have some sort of genetic study. Let’s check that with a Sankey Plot:

```{r}
# first subset the ind3_data keeping only taxa assessed a single time, plust the first record of those assessed multiple times.
ind3_data_firstmulti<-ind3_data[!duplicated(cbind(ind3_data$taxon, ind3_data$country_assessment)), ]

# transform data to how ggsankey wants it
df <- ind3_data_firstmulti %>%
  make_long(country_assessment, temp_gen_monitoring, gen_studies)

# plot
ggplot(df, aes(x = x,
               next_x = next_x,
               node = node,
               next_node = next_node,
               fill = factor(node),
               label = node)) +
  geom_sankey(flow.alpha = 0.5, 
              show.legend = FALSE) +
  geom_sankey_label(size = 2.5, color = "black", fill = "white") +
  theme_sankey(base_size = 10) +

    # manually set flow fill according to desired color
                            # countries
  scale_fill_manual(values=c(scales::hue_pal()(length(unique(ind3_data_firstmulti$country_assessment))),  
                             # traffic light for monitoring
                             c("darkolivegreen", "brown3", "darkgrey"),
                             # nice soft colors for gen_studies
                             c("grey50", "grey35", "grey50", "brown3")),
                              
                    breaks=c(unique(ind3_data_firstmulti$country_assessment),
                             unique(ind3_data_firstmulti$temp_gen_monitoring),
                             unique(ind3_data_firstmulti$gen_studies))) +
  
  xlab("")
```

```{r}
table(ind3_data_firstmulti$gen_studies)
```


Count data:
```{r}
ind3_data %>%
                 # keep only one record if the taxon was assessed more than once within the country
                 select(country_assessment, taxon, gen_studies, temp_gen_monitoring) %>%
                 filter(!duplicated(.)) %>%

                 group_by(country_assessment, temp_gen_monitoring, gen_studies) %>%
                 summarise(n_studies=n())
```

How many genetic studies ara available by country for species without temporal genetic diversity monitoring?
```{r}
## plot
indicators_full %>%
                 # keep only one record if the taxon was assessed more than once within the country
                 select(country_assessment, taxon, temp_gen_monitoring, gen_studies) %>%
                 filter(!duplicated(.)) %>%
                 # keep only taxa without gen div monitoring
                 filter(temp_gen_monitoring=="no")%>%

ggplot(aes(x=country_assessment, fill=gen_studies)) +
  geom_bar() +
    scale_fill_manual(values=c("grey80", scales::hue_pal()(3)))+
  xlab("")  +
      theme_light()
```

## Summary table of mean indicator values and n

The tables below show the indicator values and sampling size averaging them by country, taxonomic group, distribution type or IUCN global red list status. For this summary the mean of the multiassessed species was considering and counted as a single entry for the sampling size. 

Codes for indicator names:

- **PM.ind**: Proportion of Mantained populations indicator (indicator 2)
- **Ne.ind**: Proportion of populations where Ne>500 indicator (indicator 1)
- **Mon.ind**: Number of species where genetic diversity monitoring is taking place (indicator 3)

Codes for summary stats:

- **n**: sampling size (number of taxa assessed) without missing data
- **mean**: mean value for the indicator value
- **sd**: standar deviation for the indicator value

Summary stats by country:
```{r}
x<-indicators_averaged_one %>% 
                group_by(country_assessment) %>%
                summarise(n.PM.ind=sum(!is.na(indicator2)), 
                          mean.PM.ind=mean(indicator2, na.rm=TRUE),
                          sd.PM.ind=sd(indicator2, na.rm=TRUE),
                          n.Ne.ind=sum(!is.na(indicator1)), 
                          mean.Ne.ind=mean(indicator1, na.rm=TRUE),
                          sd.Ne.ind=sd(indicator1, na.rm=TRUE),
                          Mon.ind=sum(temp_gen_monitoring=="yes"))

# nice table
kable(x, digits=3)

```


### Taxonomic groups

Summary stats by taxonomic group:

```{r}
x<-indicators_averaged_one %>% 
                group_by(taxonomic_group) %>%
                summarise(n.PM.ind=sum(!is.na(indicator2)), 
                          mean.PM.ind=mean(indicator2, na.rm=TRUE),
                          sd.PM.ind=sd(indicator2, na.rm=TRUE),
                          n.Ne.ind=sum(!is.na(indicator1)), 
                          mean.Ne.ind=mean(indicator1, na.rm=TRUE),
                          sd.Ne.ind=sd(indicator1, na.rm=TRUE),
                          Mon.ind=sum(temp_gen_monitoring=="yes"))

# nice table
kable(x, digits=3)

```

Detailed table:

```{r}
x<-indicators_averaged_one %>% 
                group_by(country_assessment, taxonomic_group) %>%
                summarise(n.PM.ind=sum(!is.na(indicator2)), 
                          mean.PM.ind=mean(indicator2, na.rm=TRUE),
                          sd.PM.ind=sd(indicator2, na.rm=TRUE),
                          n.Ne.ind=sum(!is.na(indicator1)), 
                          mean.Ne.ind=mean(indicator1, na.rm=TRUE),
                          sd.Ne.ind=sd(indicator1, na.rm=TRUE),
                          Mon.ind=sum(temp_gen_monitoring=="yes"))

# nice table
kable(x, digits=3)
```


### IUCN 

Summary stats:

```{r}
x<-indicators_averaged_one %>% 
                group_by(global_IUCN) %>%
                summarise(n.PM.ind=sum(!is.na(indicator2)), 
                          mean.PM.ind=mean(indicator2, na.rm=TRUE),
                          sd.PM.ind=sd(indicator2, na.rm=TRUE),
                          n.Ne.ind=sum(!is.na(indicator1)), 
                          mean.Ne.ind=mean(indicator1, na.rm=TRUE),
                          sd.Ne.ind=sd(indicator1, na.rm=TRUE),
                          Mon.ind=sum(temp_gen_monitoring=="yes"))

# nice table
kable(x, digits=3)

```

Detailed table by IUCN category:

```{r}
x<-indicators_averaged_one %>% 
                group_by(country_assessment, global_IUCN) %>%
                summarise(n.PM.ind=sum(!is.na(indicator2)), 
                          mean.PM.ind=mean(indicator2, na.rm=TRUE),
                          sd.PM.ind=sd(indicator2, na.rm=TRUE),
                          n.Ne.ind=sum(!is.na(indicator1)), 
                          mean.Ne.ind=mean(indicator1, na.rm=TRUE),
                          sd.Ne.ind=sd(indicator1, na.rm=TRUE),
                          Mon.ind=sum(temp_gen_monitoring=="yes"))

# nice table
kable(x, digits=3)
```


### Distribution type

Summary stats:

```{r}
x<-indicators_averaged_one %>% 
                group_by(species_range) %>%
                summarise(n.PM.ind=sum(!is.na(indicator2)), 
                          mean.PM.ind=mean(indicator2, na.rm=TRUE),
                          sd.PM.ind=sd(indicator2, na.rm=TRUE),
                          n.Ne.ind=sum(!is.na(indicator1)), 
                          mean.Ne.ind=mean(indicator1, na.rm=TRUE),
                          sd.Ne.ind=sd(indicator1, na.rm=TRUE),
                          Mon.ind=sum(temp_gen_monitoring=="yes"))

# nice table
kable(x, digits=3)

```

Detailed table by IUCN category:

```{r}
x<-indicators_averaged_one %>% 
                group_by(country_assessment, species_range) %>%
                summarise(n.PM.ind=sum(!is.na(indicator2)), 
                          mean.PM.ind=mean(indicator2, na.rm=TRUE),
                          sd.PM.ind=sd(indicator2, na.rm=TRUE),
                          n.Ne.ind=sum(!is.na(indicator1)), 
                          mean.Ne.ind=mean(indicator1, na.rm=TRUE),
                          sd.Ne.ind=sd(indicator1, na.rm=TRUE),
                          Mon.ind=sum(temp_gen_monitoring=="yes"))

# nice table
kable(x, digits=3)
```


## Simplified figures and basic stats for graphical summary and policy brief

### How many species and pops:

How many species:
```{r}
nrow(indicators_averaged_one)
```

How many populations, including all pops from species that were assessed more than once:

```{r}
nrow(ind1_data)
```


How many populations, counting only once populations from taxa assessed more than once:

```{r}
# This looks for the id of the taxa already keeping only 1 for the multiassessed taxa, and keeps those int he ind1_data (where the pops data is)
x<-ind1_data[ind1_data$X_uuid %in% indicators_averaged_one$X_uuid, ]

# the number of rows is the number of pops counting only once multiassessed taxa
nrow(x)

```


### Create new variables with simplified taxonomic groups

Animals, plants, others
```{r}

# Define the grouping map
grouping_map <- c(
  "amphibian", "bird", "fish", "invertebrate", "mammal",
  "angiosperm", "gymnosperm", "reptile", "pteridophytes", "others"
)

# Create a new variable taxonomic_group_3
indicators_averaged_one <- indicators_averaged_one %>%
                            mutate(
                              taxonomic_group_3 = case_when(
                                taxonomic_group_simplified %in% grouping_map[1:5] ~ "animals",
                                taxonomic_group_simplified %in% grouping_map[6:9] ~ "plants",
                                taxonomic_group_simplified %in% grouping_map[10] ~ "others",
                                TRUE ~ NA_character_
                              )
                            )

# reorder levels
indicators_averaged_one$taxonomic_group_3<- factor(indicators_averaged_one$taxonomic_group_3, 
                                                  levels=c("animals", "plants", "others"))

```



### Histogram for Ne > 500 indicator 

By animals, plants, others:

```{r}
# Create a histogram 
hist_p <- indicators_averaged_one %>%
                  ggplot(aes(x = indicator1_mean, fill = taxonomic_group_3)) +
                  geom_histogram( bins = 25, color="white") + # Adjust the number of bins as needed
                  labs(x = "Proportion of populations with Ne>500", y = "Frequency") +
                  scale_fill_manual(
                    values = grouped_taxon_colors, # Custom colors for animals, plants, and others
                    breaks = c("animals", "plants", "others"),
                    name = "Taxonomic Group")+
                  theme_light() +
                  theme(panel.border = element_blank(), text = element_text(size = 15)) +
                  guides(fill = guide_legend(title = NULL))

# plot
hist_p
```

Plain histogram:

```{r}
# Create a histogram 
hist_p <- indicators_averaged_one %>%
                  ggplot(aes(x = indicator1_mean)) +
                  geom_histogram( bins = 25, fill="grey30") + # Adjust the number of bins as needed
                  labs(x = "Proportion of populations with Ne>500", y = "Frequency") +
                  theme_light() +
                  theme(panel.border = element_blank(), text = element_text(size = 15)) +
                  guides(fill = guide_legend(title = NULL))

# plot
hist_p
```
```



Summary table:

### Summary table for Ne > 500 indicator 

```{r}
x  <- indicators_averaged_one %>%
               filter(!is.na(indicator1_mean)) %>% 
               filter(!is.na(taxonomic_group_3)) %>% 
               group_by(taxonomic_group_3) %>% 
               summarize(n=n(),
                         mean=mean(indicator1_mean),
                         median=median(indicator1_mean),
                         per.0=sum(indicator1_mean==0) / n *100,
                         per.below.25=sum(indicator1_mean<0.25) / n *100,
                         per.below.90=sum(indicator1_mean<0.90) / n *100,
                         per.above.75=sum(indicator1_mean>0.75)/ n *100,
                         per1=sum(indicator1_mean==1) / n *100)



# Calculate total counts and means
total_counts <- indicators_averaged_one %>%
               filter(!is.na(indicator1_mean)) %>% 
               filter(!is.na(taxonomic_group_3)) %>% 
               ungroup() %>% 
               summarize(taxonomic_group_3 = "ALL",
                          n= n(),
                          mean = mean(indicator1_mean),
                          median = median(indicator1_mean),
                          per.0=sum(indicator1_mean==0) / n *100,
                          per.below.25=sum(indicator1_mean<0.25) / n *100,
                          per.below.90=sum(indicator1_mean<0.90) / n *100,
                          per.above.75=sum(indicator1_mean>0.75)/ n *100,
                          per1=sum(indicator1_mean==1) / n *100)

# Bind the total row to the summary_table
summary_table <- bind_rows(x, total_counts)

# keep taxonomic groups as level in desired order:
summary_table$taxonomic_group_3<-factor(summary_table$taxonomic_group_3,
                                                 levels = c("animals", "plants", "others", "ALL"))
summary_table<- summary_table %>% arrange(taxonomic_group_3)

kable(summary_table, digits=2)
```


### Histogram for Proportion Mantained populations

Histogram for animal, plants, others:

```{r}
# Create a histogram 
hist_p <- indicators_averaged_one %>%
                  ggplot(aes(x = indicator2_mean, fill = taxonomic_group_3)) +
                  geom_histogram(bins = 25, color="white") + # Adjust the number of bins as needed
                  labs(x = "Proportion of maintained populations", y = "Frequency") +
                  scale_fill_manual(
                    values = grouped_taxon_colors, # Custom colors for animals, plants, and others
                    breaks = c("animals", "plants", "others"),
                    name = "Taxonomic Group")+
                  theme_light() +
                  theme(panel.border = element_blank(), text = element_text(size = 15)) +
                  guides(fill = guide_legend(title = NULL))

# plot
hist_p
```

Plain histogram

```{r}
# Create a histogram 
hist_p <- indicators_averaged_one %>%
                  ggplot(aes(x = indicator2_mean)) +
                  geom_histogram(bins = 25, fill="grey30") + # Adjust the number of bins as needed
                  labs(x = "Proportion of maintained populations", y = "Frequency") +
                  theme_light() +
                  theme(panel.border = element_blank(), text = element_text(size = 15)) +
                  guides(fill = guide_legend(title = NULL))

# plot
hist_p
```

Summary table:

### Summary table for Proportion Mantaiend populations

```{r}
x  <- indicators_averaged_one %>%
               filter(!is.na(indicator2_mean)) %>% 
               filter(!is.na(taxonomic_group_3)) %>% 
               group_by(taxonomic_group_3) %>% 
               summarize(n=n(),
                         mean=mean(indicator2_mean),
                         median=median(indicator2_mean),
                         per0=sum(indicator2_mean==0) / n *100,
                         per.below.25=sum(indicator2_mean<0.25) / n *100,
                         per.below.90=sum(indicator2_mean<0.90) / n *100,
                         per.above.75=sum(indicator2_mean>0.75) / n *100,
                         per1=sum(indicator2_mean==1) / n *100)

# Calculate total counts and means
total_counts <- indicators_averaged_one %>%
               filter(!is.na(indicator2_mean)) %>% 
               filter(!is.na(taxonomic_group_3)) %>% 
               ungroup() %>% 
               summarize(taxonomic_group_3 = "ALL",
                          n= n(),
                          mean = mean(indicator2_mean),
                          median = median(indicator2_mean),
                          per0=sum(indicator2_mean==0) / n *100,
                          per.below.25=sum(indicator2_mean<0.25) / n *100,
                          per.below.90=sum(indicator2_mean<0.90) / n *100,
                          per.above.75=sum(indicator2_mean>0.75) / n *100,
                          per1=sum(indicator2_mean==1) / n *100)

# Bind the total row to the summary_table
summary_table <- bind_rows(x, total_counts)

# keep taxonomic groups as level in desired order:
summary_table$taxonomic_group_3<-factor(summary_table$taxonomic_group_3,
                                                 levels = c("animals", "plants", "others", "ALL"))
summary_table<- summary_table %>% arrange(taxonomic_group_3)

kable(summary_table, digits=2)
```



### Data availability at population level (combining Nc and Ne) by country

```{r}
ind1_data %>%
  mutate(Ne_calculated_from = replace_na(Ne_calculated_from, "no data available")) %>%
  ggplot(aes(x=country_assessment, fill=Ne_calculated_from))+
  geom_bar(position = "fill", color="white") +
  scale_fill_manual(labels=c("genetic data", "NcPoint ratio", "NcRange ratio", "no data available"),
                      breaks=c("genetic data", "NcPoint ratio", "NcRange ratio", "no data available"),
                      values=c("darkgreen", "#0072B2", "#E69F00", "grey80")) +
  xlab("") +
  scale_x_discrete(limits=rev) + 
  ylab("Proportion of populations") +
  labs(fill="Origin of data used to estimate Ne") +
  theme_light() +
  coord_flip() +
  theme(text = element_text(size = 13), legend.position = "top", panel.border = element_blank())
  
```

### Data availability donuts

Species level yes/no
```{r}
df<- metadata %>%
     filter(popsize_data != "data_for_species") %>% # we want to show only data for pops or insufficient
     group_by(popsize_data) %>%
   summarise(n=n(),
             percentage = (n / nrow(metadata)) * 100)
   
kable(df, digits = 0)

# variable to make change the size of the hole
hsize <- 2 # to change the size of the hole. larger=bigger 
df <- df %>% 
  mutate(x = hsize)  

# donut plot
p <- ggplot(df, aes(x = hsize, y = n, fill = popsize_data)) +
  geom_col() +
  coord_polar(theta = "y") +
  scale_fill_manual(values=c("#2ca02c", "grey80"),
                    breaks=c("yes", "insuff_data_species"),
                    labels=c("Population level", "Insufficient data")) +

  xlim(c(0.2, hsize + 0.5)) + theme_void()
p


```

Population level, what kind?
```{r}
# we first need the column numbers
df<-ind1_data %>%
   mutate(Ne_calculated_from = replace_na(Ne_calculated_from, "no data available")) %>%
   group_by(Ne_calculated_from) %>%
   summarise(n=n(),
             percentage = (n / nrow(ind1_data)) * 100)
   
kable(df, digits = 0)

# variable to make change the size of the hole
hsize <- 3 # to change the size of the hole. larger=bigger 
df <- df %>% 
  mutate(x = hsize)  

# donut plot
p <- ggplot(df, aes(x = hsize, y = n, fill = Ne_calculated_from)) +
  geom_col() +
  coord_polar(theta = "y") +
  scale_fill_manual(labels=c("genetic data", "NcPoint ratio", "NcRange ratio", "no data available"),
                      breaks=c("genetic data", "NcPoint ratio", "NcRange ratio", "no data available"),
                      values=c("darkgreen", "#0072B2", "#E69F00", "grey80")) +
  xlim(c(0.2, hsize + 0.5)) + theme_void()
p

```


## Session Info for reproducibility purposes:

```{r}
sessionInfo()
```

